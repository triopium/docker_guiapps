
:tanat

"26.3"

#s(hash-table size 97 test equal rehash-size 1.5 rehash-threshold 0.8125 data ("org-elpa" ("2022-04-04 09:18:23" nil (:local-repo nil :package "org-elpa" :type git)) "melpa" ("2022-04-04 09:18:23" nil (:type git :host github :repo "melpa/melpa" :build nil :package "melpa" :local-repo "melpa")) "gnu-elpa-mirror" ("2022-04-04 09:18:23" nil (:type git :host github :repo "emacs-straight/gnu-elpa-mirror" :build nil :package "gnu-elpa-mirror" :local-repo "gnu-elpa-mirror")) "el-get" ("2022-04-04 09:18:23" nil (:type git :host github :repo "dimitri/el-get" :build nil :files ("*.el" ("recipes" "recipes/el-get.rcp") "methods" "el-get-pkg.el") :flavor melpa :package "el-get" :local-repo "el-get")) "emacsmirror-mirror" ("2022-04-04 09:18:23" nil (:type git :host github :repo "emacs-straight/emacsmirror-mirror" :build nil :package "emacsmirror-mirror" :local-repo "emacsmirror-mirror")) "straight" ("2022-04-04 09:18:23" ("emacs") (:type git :host github :repo "raxod502/straight.el" :files ("straight*.el") :branch "master" :package "straight" :local-repo "straight.el")) "use-package" ("2022-04-04 09:18:23" ("emacs" "bind-key") (:type git :flavor melpa :files (:defaults (:exclude "bind-key.el" "bind-chord.el" "use-package-chords.el" "use-package-ensure-system-package.el") "use-package-pkg.el") :host github :repo "jwiegley/use-package" :package "use-package" :local-repo "use-package")) "bind-key" ("2022-04-04 09:18:23" nil (:flavor melpa :files ("bind-key.el" "bind-key-pkg.el") :package "bind-key" :local-repo "use-package" :type git :repo "jwiegley/use-package" :host github)) "evil" ("2022-04-04 09:18:23" ("emacs" "goto-chg" "cl-lib") (:type git :flavor melpa :files (:defaults "doc/build/texinfo/evil.texi" (:exclude "evil-test-helpers.el") "evil-pkg.el") :host github :repo "emacs-evil/evil" :package "evil" :local-repo "evil")) "goto-chg" ("2022-04-04 09:18:23" ("emacs") (:type git :flavor melpa :host github :repo "emacs-evil/goto-chg" :package "goto-chg" :local-repo "goto-chg")) "evil-collection" ("2022-04-04 09:18:23" ("emacs" "evil" "annalist") (:type git :flavor melpa :files (:defaults "modes" "evil-collection-pkg.el") :host github :repo "emacs-evil/evil-collection" :package "evil-collection" :local-repo "evil-collection")) "annalist" ("2022-04-04 09:18:23" ("emacs" "cl-lib") (:type git :flavor melpa :host github :repo "noctuid/annalist.el" :package "annalist" :local-repo "annalist.el")) "solarized-theme" ("2022-04-04 09:18:23" ("emacs" "dash") (:type git :flavor melpa :host github :repo "bbatsov/solarized-emacs" :package "solarized-theme" :local-repo "solarized-emacs")) "dash" ("2022-04-04 09:18:23" ("emacs") (:type git :flavor melpa :files ("dash.el" "dash.texi" "dash-pkg.el") :host github :repo "magnars/dash.el" :package "dash" :local-repo "dash.el")) "better-jumper" ("2022-04-04 09:18:24" ("emacs") (:type git :flavor melpa :host github :repo "gilbertw1/better-jumper" :package "better-jumper" :local-repo "better-jumper")) "neotree" ("2022-04-04 09:18:24" ("cl-lib") (:type git :flavor melpa :files (:defaults "icons" "neotree-pkg.el") :host github :repo "jaypei/emacs-neotree" :package "neotree" :local-repo "emacs-neotree")) "all-the-icons" ("2022-04-04 09:18:23" ("emacs") (:type git :flavor melpa :files (:defaults "data" "all-the-icons-pkg.el") :host github :repo "domtronn/all-the-icons.el" :package "all-the-icons" :local-repo "all-the-icons.el")) "ace-window" ("2022-04-04 09:18:23" ("avy") (:type git :flavor melpa :host github :repo "abo-abo/ace-window" :package "ace-window" :local-repo "ace-window")) "avy" ("2022-04-04 09:18:23" ("emacs" "cl-lib") (:type git :flavor melpa :host github :repo "abo-abo/avy" :package "avy" :local-repo "avy")) "airline-themes" ("2022-04-04 09:18:23" ("powerline") (:type git :flavor melpa :host github :repo "AnthonyDiGirolamo/airline-themes" :package "airline-themes" :local-repo "airline-themes")) "powerline" ("2022-04-04 09:18:23" ("cl-lib") (:type git :flavor melpa :host github :repo "milkypostman/powerline" :package "powerline" :local-repo "powerline")) "spaceline" ("2021-09-12 14:52:34" ("emacs" "cl-lib" "powerline" "dash" "s") (:type git :flavor melpa :host github :repo "TheBB/spaceline" :package "spaceline" :local-repo "spaceline")) "s" ("2022-04-04 09:18:24" nil (:type git :flavor melpa :files ("s.el" "s-pkg.el") :host github :repo "magnars/s.el" :package "s" :local-repo "s.el")) "rainbow-delimiters" ("2022-04-04 09:18:24" nil (:type git :flavor melpa :host github :repo "Fanael/rainbow-delimiters" :package "rainbow-delimiters" :local-repo "rainbow-delimiters")) "f" ("2022-04-04 09:18:24" ("s" "dash") (:type git :flavor melpa :files ("f.el" "f-pkg.el") :host github :repo "rejeep/f.el" :package "f" :local-repo "f.el")) "undo-tree" ("2022-04-04 09:18:24" nil (:type git :host github :repo "emacs-straight/undo-tree" :files ("*" (:exclude ".git")) :package "undo-tree" :local-repo "undo-tree")) "path-headerline-mode" ("2022-04-04 09:18:23" nil (:type git :flavor melpa :host github :repo "7696122/path-headerline-mode" :package "path-headerline-mode" :local-repo "path-headerline-mode")) "powerline-evil" ("2021-09-10 10:19:19" ("evil" "powerline") (:type git :flavor melpa :host github :repo "johnson-christopher/powerline-evil" :package "powerline-evil" :local-repo "powerline-evil")) "evil-matchit" ("2021-09-10 10:19:19" ("evil" "emacs") (:type git :flavor melpa :host github :repo "redguardtoo/evil-matchit" :package "evil-matchit" :local-repo "evil-matchit")) "evil-leader" ("2022-04-04 09:18:23" ("evil") (:type git :flavor melpa :host github :repo "cofi/evil-leader" :package "evil-leader" :local-repo "evil-leader")) "evil-easymotion" ("2021-09-15 07:42:35" ("emacs" "avy" "cl-lib") (:type git :flavor melpa :host github :repo "PythonNut/evil-easymotion" :package "evil-easymotion" :local-repo "evil-easymotion")) "which-key" ("2022-04-04 09:18:24" ("emacs") (:type git :flavor melpa :host github :repo "justbur/emacs-which-key" :package "which-key" :local-repo "emacs-which-key")) "remind-bindings" ("2022-04-04 09:18:24" ("emacs" "omni-quotes" "popwin" "map") (:type git :flavor melpa :host gitlab :repo "mtekman/remind-bindings.el" :package "remind-bindings" :local-repo "remind-bindings.el")) "omni-quotes" ("2022-04-04 09:18:24" ("dash" "omni-log" "f" "s" "ht") (:type git :flavor melpa :host github :repo "AdrieanKhisbe/omni-quotes.el" :package "omni-quotes" :local-repo "omni-quotes.el")) "omni-log" ("2022-04-04 09:18:24" ("emacs" "ht" "s" "dash") (:type git :flavor melpa :host github :repo "AdrieanKhisbe/omni-log.el" :package "omni-log" :local-repo "omni-log.el")) "ht" ("2022-04-04 09:18:24" ("dash") (:type git :flavor melpa :files ("ht.el" "ht-pkg.el") :host github :repo "Wilfred/ht.el" :package "ht" :local-repo "ht.el")) "popwin" ("2022-04-04 09:18:24" ("emacs") (:type git :flavor melpa :host github :repo "emacsorphanage/popwin" :package "popwin" :local-repo "popwin")) "map" ("2022-04-04 09:18:24" ("emacs") (:type git :host github :repo "emacs-straight/map" :files ("*" (:exclude ".git")) :package "map" :local-repo "map")) "company" ("2022-04-04 09:18:24" ("emacs") (:type git :flavor melpa :files (:defaults "icons" "company-pkg.el") :host github :repo "company-mode/company-mode" :package "company" :local-repo "company-mode")) "ido-completing-read+" ("2022-04-04 09:18:24" ("emacs" "seq" "memoize") (:type git :flavor melpa :files ("ido-completing-read+.el" "ido-completing-read+-pkg.el") :host github :repo "DarwinAwardWinner/ido-completing-read-plus" :package "ido-completing-read+" :local-repo "ido-completing-read-plus")) "memoize" ("2022-04-04 09:18:24" nil (:type git :flavor melpa :host github :repo "skeeto/emacs-memoize" :package "memoize" :local-repo "emacs-memoize")) "lsp-mode" ("2022-04-04 09:18:24" ("emacs" "dash" "f" "ht" "spinner" "markdown-mode" "lv") (:type git :flavor melpa :files (:defaults "clients/*.el" "lsp-mode-pkg.el") :host github :repo "emacs-lsp/lsp-mode" :package "lsp-mode" :local-repo "lsp-mode")) "spinner" ("2022-04-04 09:18:24" ("emacs") (:type git :host github :repo "emacs-straight/spinner" :files ("*" (:exclude ".git")) :package "spinner" :local-repo "spinner")) "markdown-mode" ("2022-04-04 09:18:24" ("emacs") (:type git :flavor melpa :host github :repo "jrblevin/markdown-mode" :package "markdown-mode" :local-repo "markdown-mode")) "lv" ("2022-04-04 09:18:24" nil (:type git :flavor melpa :files ("lv.el" "lv-pkg.el") :host github :repo "abo-abo/hydra" :package "lv" :local-repo "hydra")) "lsp-ui" ("2022-04-04 09:18:24" ("emacs" "dash" "lsp-mode" "markdown-mode") (:type git :flavor melpa :files (:defaults "lsp-ui-doc.html" "resources" "lsp-ui-pkg.el") :host github :repo "emacs-lsp/lsp-ui" :package "lsp-ui" :local-repo "lsp-ui")) "esup" ("2022-04-04 09:18:24" ("cl-lib" "s" "emacs") (:type git :flavor melpa :host github :repo "jschaf/esup" :package "esup" :local-repo "esup")) "treemacs" ("2022-04-04 09:18:24" ("emacs" "cl-lib" "dash" "s" "ace-window" "pfuture" "hydra" "ht" "cfrs") (:type git :flavor melpa :files (:defaults "Changelog.org" "icons" "src/elisp/treemacs*.el" "src/scripts/treemacs*.py" (:exclude "src/extra/*") "treemacs-pkg.el") :host github :repo "Alexander-Miller/treemacs" :package "treemacs" :local-repo "treemacs")) "pfuture" ("2022-04-04 09:18:24" ("emacs") (:type git :flavor melpa :host github :repo "Alexander-Miller/pfuture" :package "pfuture" :local-repo "pfuture")) "hydra" ("2022-04-04 09:18:24" ("cl-lib" "lv") (:flavor melpa :files (:defaults (:exclude "lv.el") "hydra-pkg.el") :package "hydra" :local-repo "hydra" :type git :repo "abo-abo/hydra" :host github)) "cfrs" ("2022-04-04 09:18:24" ("emacs" "dash" "s" "posframe") (:type git :flavor melpa :host github :repo "Alexander-Miller/cfrs" :package "cfrs" :local-repo "cfrs")) "posframe" ("2022-04-04 09:18:24" ("emacs") (:type git :flavor melpa :host github :repo "tumashu/posframe" :package "posframe" :local-repo "posframe")) "company-lsp" ("2022-04-04 09:18:24" ("emacs" "lsp-mode" "company" "s" "dash") (:type git :host github :repo "emacsattic/company-lsp" :package "company-lsp" :local-repo "company-lsp")) "lsp-origami" ("2022-04-04 09:18:24" ("origami" "lsp-mode") (:type git :flavor melpa :host github :repo "emacs-lsp/lsp-origami" :package "lsp-origami" :local-repo "lsp-origami")) "origami" ("2022-04-04 09:18:24" ("s" "dash" "emacs" "cl-lib") (:type git :flavor melpa :host github :repo "gregsexton/origami.el" :package "origami" :local-repo "origami.el")) "go-mode" ("2022-04-04 09:18:24" nil (:type git :flavor melpa :files ("go-mode.el" "go-mode-pkg.el") :host github :repo "dominikh/go-mode.el" :package "go-mode" :local-repo "go-mode.el")) "flycheck" ("2022-04-04 09:18:24" ("dash" "pkg-info" "let-alist" "seq" "emacs") (:type git :flavor melpa :host github :repo "flycheck/flycheck" :package "flycheck" :local-repo "flycheck")) "pkg-info" ("2022-04-04 09:18:24" ("epl") (:type git :flavor melpa :host github :repo "emacsorphanage/pkg-info" :package "pkg-info" :local-repo "pkg-info")) "epl" ("2022-04-04 09:18:24" ("cl-lib") (:type git :flavor melpa :host github :repo "cask/epl" :package "epl" :local-repo "epl")) "let-alist" ("2022-04-04 09:18:24" ("emacs") (:type git :host github :repo "emacs-straight/let-alist" :files ("*" (:exclude ".git")) :package "let-alist" :local-repo "let-alist")) "go-guru" ("2021-12-15 19:12:13" ("go-mode" "cl-lib") (:flavor melpa :files ("go-guru.el" "go-guru-pkg.el") :package "go-guru" :local-repo "go-mode.el" :type git :repo "dominikh/go-mode.el" :host github)) "go-rename" ("2021-12-15 19:12:13" ("go-mode") (:flavor melpa :files ("go-rename.el" "go-rename-pkg.el") :package "go-rename" :local-repo "go-mode.el" :type git :repo "dominikh/go-mode.el" :host github)) "restclient" ("2022-04-04 09:18:24" nil (:type git :flavor melpa :files ("restclient.el" "restclient-pkg.el") :host github :repo "pashky/restclient.el" :package "restclient" :local-repo "restclient.el")) "company-restclient" ("2022-02-18 16:02:23" ("cl-lib" "company" "emacs" "know-your-http-well" "restclient") (:type git :flavor melpa :host github :repo "iquiw/company-restclient" :package "company-restclient" :local-repo "company-restclient")) "know-your-http-well" ("2022-02-18 16:02:23" nil (:type git :flavor melpa :files ("emacs/*.el" "know-your-http-well-pkg.el") :host github :repo "for-GET/know-your-http-well" :package "know-your-http-well" :local-repo "know-your-http-well")) "smooth-scrolling" ("2022-04-04 09:18:23" nil (:type git :flavor melpa :host github :repo "aspiers/smooth-scrolling" :package "smooth-scrolling" :local-repo "smooth-scrolling")) "docker-compose-mode" ("2022-04-04 09:18:24" ("emacs" "dash" "yaml-mode") (:type git :flavor melpa :files (:defaults (:exclude "docker-compose-mode-helpers.el") "docker-compose-mode-pkg.el") :host github :repo "meqif/docker-compose-mode" :package "docker-compose-mode" :local-repo "docker-compose-mode")) "yaml-mode" ("2022-04-04 09:18:24" ("emacs") (:type git :flavor melpa :host github :repo "yoshiki/yaml-mode" :package "yaml-mode" :local-repo "yaml-mode")) "dockerfile-mode" ("2022-04-04 09:18:24" ("emacs") (:type git :flavor melpa :host github :repo "spotify/dockerfile-mode" :package "dockerfile-mode" :local-repo "dockerfile-mode")) "go-fill-struct" ("2022-04-04 09:18:24" ("emacs") (:type git :flavor melpa :host github :repo "s-kostyaev/go-fill-struct" :package "go-fill-struct" :local-repo "go-fill-struct")) "yasnippet" ("2022-04-04 09:18:24" ("cl-lib") (:type git :flavor melpa :files ("yasnippet.el" "snippets" "yasnippet-pkg.el") :host github :repo "joaotavora/yasnippet" :package "yasnippet" :local-repo "yasnippet")) "yasnippet-snippets" ("2022-04-04 09:18:24" ("yasnippet") (:type git :flavor melpa :files ("*.el" "snippets" ".nosearch" "yasnippet-snippets-pkg.el") :host github :repo "AndreaCrotti/yasnippet-snippets" :package "yasnippet-snippets" :local-repo "yasnippet-snippets")) "rich-minority" ("2022-02-18 15:43:02" ("cl-lib") (:type git :flavor melpa :host github :repo "Malabarba/rich-minority" :package "rich-minority" :local-repo "rich-minority")) "diminish" ("2022-04-04 09:18:24" ("emacs") (:type git :flavor melpa :host github :repo "myrjola/diminish.el" :package "diminish" :local-repo "diminish.el")) "zoom-window" ("2022-04-04 09:18:24" ("emacs") (:type git :flavor melpa :host github :repo "emacsorphanage/zoom-window" :package "zoom-window" :local-repo "zoom-window")) "vlf" ("2022-04-04 09:18:24" nil (:type git :flavor melpa :host github :repo "m00natic/vlfi" :package "vlf" :local-repo "vlfi"))))

#s(hash-table size 97 test equal rehash-size 1.5 rehash-threshold 0.8125 data ("straight" ((straight straight-autoloads straight-x) (autoload (quote straight-remove-unused-repos) "straight" "Remove unused repositories from the repos directory.
A repo is considered \"unused\" if it was not explicitly requested via
`straight-use-package' during the current Emacs session.
If FORCE is non-nil do not prompt before deleting repos.

(fn &optional FORCE)" t nil) (autoload (quote straight-get-recipe) "straight" "Interactively select a recipe from one of the recipe repositories.
All recipe repositories in `straight-recipe-repositories' will
first be cloned. After the recipe is selected, it will be copied
to the kill ring. With a prefix argument, first prompt for a
recipe repository to search. Only that repository will be
cloned.

From Lisp code, SOURCES should be a subset of the symbols in
`straight-recipe-repositories'. Only those recipe repositories
are cloned and searched. If it is nil or omitted, then the value
of `straight-recipe-repositories' is used. If SOURCES is the
symbol `interactive', then the user is prompted to select a
recipe repository, and a list containing that recipe repository
is used for the value of SOURCES. ACTION may be `copy' (copy
recipe to the kill ring), `insert' (insert at point), or nil (no
action, just return it).

(fn &optional SOURCES ACTION)" t nil) (autoload (quote straight-visit-package-website) "straight" "Interactively select a recipe, and visit the package's website.

(fn)" t nil) (autoload (quote straight-use-package) "straight" "Register, clone, build, and activate a package and its dependencies.
This is the main entry point to the functionality of straight.el.

MELPA-STYLE-RECIPE is either a symbol naming a package, or a list
whose car is a symbol naming a package and whose cdr is a
property list containing e.g. `:type', `:local-repo', `:files',
and VC backend specific keywords.

First, the package recipe is registered with straight.el. If
NO-CLONE is a function, then it is called with two arguments: the
package name as a string, and a boolean value indicating whether
the local repository for the package is available. In that case,
the return value of the function is used as the value of NO-CLONE
instead. In any case, if NO-CLONE is non-nil, then processing
stops here.

Otherwise, the repository is cloned, if it is missing. If
NO-BUILD is a function, then it is called with one argument: the
package name as a string. In that case, the return value of the
function is used as the value of NO-BUILD instead. In any case,
if NO-BUILD is non-nil, then processing halts here. Otherwise,
the package is built and activated. Note that if the package
recipe has a nil `:build' entry, then NO-BUILD is ignored
and processing always stops before building and activation
occurs.

CAUSE is a string explaining the reason why
`straight-use-package' has been called. It is for internal use
only, and is used to construct progress messages. INTERACTIVE is
non-nil if the function has been called interactively. It is for
internal use only, and is used to determine whether to show a
hint about how to install the package permanently.

Return non-nil if package was actually installed, and nil
otherwise (this can only happen if NO-CLONE is non-nil).

(fn MELPA-STYLE-RECIPE &optional NO-CLONE NO-BUILD CAUSE INTERACTIVE)" t nil) (autoload (quote straight-register-package) "straight" "Register a package without cloning, building, or activating it.
This function is equivalent to calling `straight-use-package'
with a non-nil argument for NO-CLONE. It is provided for
convenience. MELPA-STYLE-RECIPE is as for
`straight-use-package'.

(fn MELPA-STYLE-RECIPE)" nil nil) (autoload (quote straight-use-package-no-build) "straight" "Register and clone a package without building it.
This function is equivalent to calling `straight-use-package'
with nil for NO-CLONE but a non-nil argument for NO-BUILD. It is
provided for convenience. MELPA-STYLE-RECIPE is as for
`straight-use-package'.

(fn MELPA-STYLE-RECIPE)" nil nil) (autoload (quote straight-use-package-lazy) "straight" "Register, build, and activate a package if it is already cloned.
This function is equivalent to calling `straight-use-package'
with symbol `lazy' for NO-CLONE. It is provided for convenience.
MELPA-STYLE-RECIPE is as for `straight-use-package'.

(fn MELPA-STYLE-RECIPE)" nil nil) (autoload (quote straight-use-recipes) "straight" "Register a recipe repository using MELPA-STYLE-RECIPE.
This registers the recipe and builds it if it is already cloned.
Note that you probably want the recipe for a recipe repository to
include a nil `:build' property, to unconditionally
inhibit the build phase.

This function also adds the recipe repository to
`straight-recipe-repositories', at the end of the list.

(fn MELPA-STYLE-RECIPE)" nil nil) (autoload (quote straight-override-recipe) "straight" "Register MELPA-STYLE-RECIPE as a recipe override.
This puts it in `straight-recipe-overrides', depending on the
value of `straight-current-profile'.

(fn MELPA-STYLE-RECIPE)" nil nil) (autoload (quote straight-check-package) "straight" "Rebuild a PACKAGE if it has been modified.
PACKAGE is a string naming a package. Interactively, select
PACKAGE from the known packages in the current Emacs session
using `completing-read'. See also `straight-rebuild-package' and
`straight-check-all'.

(fn PACKAGE)" t nil) (autoload (quote straight-check-all) "straight" "Rebuild any packages that have been modified.
See also `straight-rebuild-all' and `straight-check-package'.
This function should not be called during init.

(fn)" t nil) (autoload (quote straight-rebuild-package) "straight" "Rebuild a PACKAGE.
PACKAGE is a string naming a package. Interactively, select
PACKAGE from the known packages in the current Emacs session
using `completing-read'. With prefix argument RECURSIVE, rebuild
all dependencies as well. See also `straight-check-package' and
`straight-rebuild-all'.

(fn PACKAGE &optional RECURSIVE)" t nil) (autoload (quote straight-rebuild-all) "straight" "Rebuild all packages.
See also `straight-check-all' and `straight-rebuild-package'.

(fn)" t nil) (autoload (quote straight-prune-build-cache) "straight" "Prune the build cache.
This means that only packages that were built in the last init
run and subsequent interactive session will remain; other
packages will have their build mtime information and any cached
autoloads discarded.

(fn)" nil nil) (autoload (quote straight-prune-build-directory) "straight" "Prune the build directory.
This means that only packages that were built in the last init
run and subsequent interactive session will remain; other
packages will have their build directories deleted.

(fn)" nil nil) (autoload (quote straight-prune-build) "straight" "Prune the build cache and build directory.
This means that only packages that were built in the last init
run and subsequent interactive session will remain; other
packages will have their build mtime information discarded and
their build directories deleted.

(fn)" t nil) (autoload (quote straight-normalize-package) "straight" "Normalize a PACKAGE's local repository to its recipe's configuration.
PACKAGE is a string naming a package. Interactively, select
PACKAGE from the known packages in the current Emacs session
using `completing-read'.

(fn PACKAGE)" t nil) (autoload (quote straight-normalize-all) "straight" "Normalize all packages. See `straight-normalize-package'.
Return a list of recipes for packages that were not successfully
normalized. If multiple packages come from the same local
repository, only one is normalized.

PREDICATE, if provided, filters the packages that are normalized.
It is called with the package name as a string, and should return
non-nil if the package should actually be normalized.

(fn &optional PREDICATE)" t nil) (autoload (quote straight-fetch-package) "straight" "Try to fetch a PACKAGE from the primary remote.
PACKAGE is a string naming a package. Interactively, select
PACKAGE from the known packages in the current Emacs session
using `completing-read'. With prefix argument FROM-UPSTREAM,
fetch not just from primary remote but also from upstream (for
forked packages).

(fn PACKAGE &optional FROM-UPSTREAM)" t nil) (autoload (quote straight-fetch-package-and-deps) "straight" "Try to fetch a PACKAGE and its (transitive) dependencies.
PACKAGE, its dependencies, their dependencies, etc. are fetched
from their primary remotes.

PACKAGE is a string naming a package. Interactively, select
PACKAGE from the known packages in the current Emacs session
using `completing-read'. With prefix argument FROM-UPSTREAM,
fetch not just from primary remote but also from upstream (for
forked packages).

(fn PACKAGE &optional FROM-UPSTREAM)" t nil) (autoload (quote straight-fetch-all) "straight" "Try to fetch all packages from their primary remotes.
With prefix argument FROM-UPSTREAM, fetch not just from primary
remotes but also from upstreams (for forked packages).

Return a list of recipes for packages that were not successfully
fetched. If multiple packages come from the same local
repository, only one is fetched.

PREDICATE, if provided, filters the packages that are fetched. It
is called with the package name as a string, and should return
non-nil if the package should actually be fetched.

(fn &optional FROM-UPSTREAM PREDICATE)" t nil) (autoload (quote straight-merge-package) "straight" "Try to merge a PACKAGE from the primary remote.
PACKAGE is a string naming a package. Interactively, select
PACKAGE from the known packages in the current Emacs session
using `completing-read'. With prefix argument FROM-UPSTREAM,
merge not just from primary remote but also from upstream (for
forked packages).

(fn PACKAGE &optional FROM-UPSTREAM)" t nil) (autoload (quote straight-merge-package-and-deps) "straight" "Try to merge a PACKAGE and its (transitive) dependencies.
PACKAGE, its dependencies, their dependencies, etc. are merged
from their primary remotes.

PACKAGE is a string naming a package. Interactively, select
PACKAGE from the known packages in the current Emacs session
using `completing-read'. With prefix argument FROM-UPSTREAM,
merge not just from primary remote but also from upstream (for
forked packages).

(fn PACKAGE &optional FROM-UPSTREAM)" t nil) (autoload (quote straight-merge-all) "straight" "Try to merge all packages from their primary remotes.
With prefix argument FROM-UPSTREAM, merge not just from primary
remotes but also from upstreams (for forked packages).

Return a list of recipes for packages that were not successfully
merged. If multiple packages come from the same local
repository, only one is merged.

PREDICATE, if provided, filters the packages that are merged. It
is called with the package name as a string, and should return
non-nil if the package should actually be merged.

(fn &optional FROM-UPSTREAM PREDICATE)" t nil) (autoload (quote straight-pull-package) "straight" "Try to pull a PACKAGE from the primary remote.
PACKAGE is a string naming a package. Interactively, select
PACKAGE from the known packages in the current Emacs session
using `completing-read'. With prefix argument FROM-UPSTREAM, pull
not just from primary remote but also from upstream (for forked
packages).

(fn PACKAGE &optional FROM-UPSTREAM)" t nil) (autoload (quote straight-pull-package-and-deps) "straight" "Try to pull a PACKAGE and its (transitive) dependencies.
PACKAGE, its dependencies, their dependencies, etc. are pulled
from their primary remotes.

PACKAGE is a string naming a package. Interactively, select
PACKAGE from the known packages in the current Emacs session
using `completing-read'. With prefix argument FROM-UPSTREAM,
pull not just from primary remote but also from upstream (for
forked packages).

(fn PACKAGE &optional FROM-UPSTREAM)" t nil) (autoload (quote straight-pull-all) "straight" "Try to pull all packages from their primary remotes.
With prefix argument FROM-UPSTREAM, pull not just from primary
remotes but also from upstreams (for forked packages).

Return a list of recipes for packages that were not successfully
pulled. If multiple packages come from the same local repository,
only one is pulled.

PREDICATE, if provided, filters the packages that are pulled. It
is called with the package name as a string, and should return
non-nil if the package should actually be pulled.

(fn &optional FROM-UPSTREAM PREDICATE)" t nil) (autoload (quote straight-push-package) "straight" "Push a PACKAGE to its primary remote, if necessary.
PACKAGE is a string naming a package. Interactively, select
PACKAGE from the known packages in the current Emacs session
using `completing-read'.

(fn PACKAGE)" t nil) (autoload (quote straight-push-all) "straight" "Try to push all packages to their primary remotes.

Return a list of recipes for packages that were not successfully
pushed. If multiple packages come from the same local repository,
only one is pushed.

PREDICATE, if provided, filters the packages that are normalized.
It is called with the package name as a string, and should return
non-nil if the package should actually be normalized.

(fn &optional PREDICATE)" t nil) (autoload (quote straight-freeze-versions) "straight" "Write version lockfiles for currently activated packages.
This implies first pushing all packages that have unpushed local
changes. If the package management system has been used since the
last time the init-file was reloaded, offer to fix the situation
by reloading the init-file again. If FORCE is
non-nil (interactively, if a prefix argument is provided), skip
all checks and write the lockfile anyway.

Currently, writing version lockfiles requires cloning all lazily
installed packages. Hopefully, this inconvenient requirement will
be removed in the future.

Multiple lockfiles may be written (one for each profile),
according to the value of `straight-profiles'.

(fn &optional FORCE)" t nil) (autoload (quote straight-thaw-versions) "straight" "Read version lockfiles and restore package versions to those listed.

(fn)" t nil) (autoload (quote straight-bug-report) "straight" "Test straight.el in a clean environment.
ARGS may be any of the following keywords and their respective values:
  - :pre-bootstrap (Form)...
      Forms evaluated before bootstrapping straight.el
      e.g. (setq straight-repository-branch \"develop\")
      Note this example is already in the default bootstrapping code.

  - :post-bootstrap (Form)...
      Forms evaluated in the testing environment after boostrapping.
      e.g. (straight-use-package '(example :type git :host github))

  - :interactive Boolean
      If nil, the subprocess will immediately exit after the test.
      Output will be printed to `straight-bug-report--process-buffer'
      Otherwise, the subprocess will be interactive.

  - :preserve Boolean
      If non-nil, the test directory is left in the directory stored in the
      variable `temporary-file-directory'. Otherwise, it is
      immediately removed after the test is run.

  - :executable String
      Indicate the Emacs executable to launch.
      Defaults to the path of the current Emacs executable.

  - :raw Boolean
      If non-nil, the raw process output is sent to
      `straight-bug-report--process-buffer'. Otherwise, it is
      formatted as markdown for submitting as an issue.

  - :user-dir String
      If non-nil, the test is run with `user-emacs-directory' set to STRING.
      Otherwise, a temporary directory is created and used.
      Unless absolute, paths are expanded relative to the variable
      `temporary-file-directory'.

ARGS are accessible within the :pre/:post-bootsrap phases via the
locally bound plist, straight-bug-report-args.

(fn &rest ARGS)" nil t) (function-put (quote straight-bug-report) (quote lisp-indent-function) (quote 0)) (autoload (quote straight-dependencies) "straight" "Return a list of PACKAGE's dependencies.

(fn &optional PACKAGE)" t nil) (autoload (quote straight-dependents) "straight" "Return a list PACKAGE's dependents.

(fn &optional PACKAGE)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "straight" (quote ("straight-")))) (defvar straight-x-pinned-packages nil "List of pinned packages.") (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "straight-x" (quote ("straight-x-")))) (provide (quote straight-autoloads))) "bind-key" ((bind-key-autoloads bind-key) (autoload (quote bind-key) "bind-key" "Bind KEY-NAME to COMMAND in KEYMAP (`global-map' if not passed).

KEY-NAME may be a vector, in which case it is passed straight to
`define-key'. Or it may be a string to be interpreted as
spelled-out keystrokes, e.g., \"C-c C-z\". See documentation of
`edmacro-mode' for details.

COMMAND must be an interactive function or lambda form.

KEYMAP, if present, should be a keymap variable or symbol.
For example:

  (bind-key \"M-h\" #'some-interactive-function my-mode-map)

  (bind-key \"M-h\" #'some-interactive-function 'my-mode-map)

If PREDICATE is non-nil, it is a form evaluated to determine when
a key should be bound. It must return non-nil in such cases.
Emacs can evaluate this form at any time that it does redisplay
or operates on menu data structures, so you should write it so it
can safely be called at any time.

(fn KEY-NAME COMMAND &optional KEYMAP PREDICATE)" nil t) (autoload (quote unbind-key) "bind-key" "Unbind the given KEY-NAME, within the KEYMAP (if specified).
See `bind-key' for more details.

(fn KEY-NAME &optional KEYMAP)" nil t) (autoload (quote bind-key*) "bind-key" "Similar to `bind-key', but overrides any mode-specific bindings.

(fn KEY-NAME COMMAND &optional PREDICATE)" nil t) (autoload (quote bind-keys) "bind-key" "Bind multiple keys at once.

Accepts keyword arguments:
:map MAP               - a keymap into which the keybindings should be
                         added
:prefix KEY            - prefix key for these bindings
:prefix-map MAP        - name of the prefix map that should be created
                         for these bindings
:prefix-docstring STR  - docstring for the prefix-map variable
:menu-name NAME        - optional menu string for prefix map
:filter FORM           - optional form to determine when bindings apply

The rest of the arguments are conses of keybinding string and a
function symbol (unquoted).

(fn &rest ARGS)" nil t) (autoload (quote bind-keys*) "bind-key" "

(fn &rest ARGS)" nil t) (autoload (quote describe-personal-keybindings) "bind-key" "Display all the personal keybindings defined by `bind-key'.

(fn)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "bind-key" (quote ("compare-keybindings" "get-binding-description" "bind-key" "personal-keybindings" "override-global-m")))) (provide (quote bind-key-autoloads))) "use-package" ((use-package use-package-autoloads use-package-ensure use-package-core use-package-lint use-package-jump use-package-delight use-package-bind-key use-package-diminish) (autoload (quote use-package-autoload-keymap) "use-package-bind-key" "Loads PACKAGE and then binds the key sequence used to invoke
this function to KEYMAP-SYMBOL. It then simulates pressing the
same key sequence a again, so that the next key pressed is routed
to the newly loaded keymap.

This function supports use-package's :bind-keymap keyword. It
works by binding the given key sequence to an invocation of this
function for a particular keymap. The keymap is expected to be
defined by the package. In this way, loading the package is
deferred until the prefix key sequence is pressed.

(fn KEYMAP-SYMBOL PACKAGE OVERRIDE)" nil nil) (autoload (quote use-package-normalize-binder) "use-package-bind-key" "

(fn NAME KEYWORD ARGS)" nil nil) (defalias (quote use-package-normalize/:bind) (quote use-package-normalize-binder)) (defalias (quote use-package-normalize/:bind*) (quote use-package-normalize-binder)) (defalias (quote use-package-autoloads/:bind) (quote use-package-autoloads-mode)) (defalias (quote use-package-autoloads/:bind*) (quote use-package-autoloads-mode)) (autoload (quote use-package-handler/:bind) "use-package-bind-key" "

(fn NAME KEYWORD ARGS REST STATE &optional BIND-MACRO)" nil nil) (defalias (quote use-package-normalize/:bind-keymap) (quote use-package-normalize-binder)) (defalias (quote use-package-normalize/:bind-keymap*) (quote use-package-normalize-binder)) (autoload (quote use-package-handler/:bind-keymap) "use-package-bind-key" "

(fn NAME KEYWORD ARGS REST STATE &optional OVERRIDE)" nil nil) (autoload (quote use-package-handler/:bind-keymap*) "use-package-bind-key" "

(fn NAME KEYWORD ARG REST STATE)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "use-package-bind-key" (quote ("use-package-handler/:bind*")))) (autoload (quote use-package) "use-package-core" "Declare an Emacs package by specifying a group of configuration options.

For full documentation, please see the README file that came with
this file.  Usage:

  (use-package package-name
     [:keyword [option]]...)

:init            Code to run before PACKAGE-NAME has been loaded.
:config          Code to run after PACKAGE-NAME has been loaded.  Note that
                 if loading is deferred for any reason, this code does not
                 execute until the lazy load has occurred.
:preface         Code to be run before everything except `:disabled'; this
                 can be used to define functions for use in `:if', or that
                 should be seen by the byte-compiler.

:mode            Form to be added to `auto-mode-alist'.
:magic           Form to be added to `magic-mode-alist'.
:magic-fallback  Form to be added to `magic-fallback-mode-alist'.
:interpreter     Form to be added to `interpreter-mode-alist'.

:commands        Define autoloads for commands that will be defined by the
                 package.  This is useful if the package is being lazily
                 loaded, and you wish to conditionally call functions in your
                 `:init' block that are defined in the package.
:hook            Specify hook(s) to attach this package to.

:bind            Bind keys, and define autoloads for the bound commands.
:bind*           Bind keys, and define autoloads for the bound commands,
                 *overriding all minor mode bindings*.
:bind-keymap     Bind a key prefix to an auto-loaded keymap defined in the
                 package.  This is like `:bind', but for keymaps.
:bind-keymap*    Like `:bind-keymap', but overrides all minor mode bindings

:defer           Defer loading of a package -- this is implied when using
                 `:commands', `:bind', `:bind*', `:mode', `:magic', `:hook',
                 `:magic-fallback', or `:interpreter'.  This can be an integer,
                 to force loading after N seconds of idle time, if the package
                 has not already been loaded.
:after           Delay the use-package declaration until after the named modules
                 have loaded. Once load, it will be as though the use-package
                 declaration (without `:after') had been seen at that moment.
:demand          Prevent the automatic deferred loading introduced by constructs
                 such as `:bind' (see `:defer' for the complete list).

:if EXPR         Initialize and load only if EXPR evaluates to a non-nil value.
:disabled        The package is ignored completely if this keyword is present.
:defines         Declare certain variables to silence the byte-compiler.
:functions       Declare certain functions to silence the byte-compiler.
:load-path       Add to the `load-path' before attempting to load the package.
:diminish        Support for diminish.el (if installed).
:delight         Support for delight.el (if installed).
:custom          Call `custom-set' or `set-default' with each variable
                 definition without modifying the Emacs `custom-file'.
                 (compare with `custom-set-variables').
:custom-face     Call `customize-set-faces' with each face definition.
:ensure          Loads the package using package.el if necessary.
:pin             Pin the package to an archive.

(fn NAME &rest ARGS)" nil t) (function-put (quote use-package) (quote lisp-indent-function) (quote 1)) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "use-package-core" (quote ("use-package-")))) (autoload (quote use-package-normalize/:delight) "use-package-delight" "Normalize arguments to delight.

(fn NAME KEYWORD ARGS)" nil nil) (autoload (quote use-package-handler/:delight) "use-package-delight" "

(fn NAME KEYWORD ARGS REST STATE)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "use-package-delight" (quote ("use-package-normalize-delight")))) (autoload (quote use-package-normalize/:diminish) "use-package-diminish" "

(fn NAME KEYWORD ARGS)" nil nil) (autoload (quote use-package-handler/:diminish) "use-package-diminish" "

(fn NAME KEYWORD ARG REST STATE)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "use-package-diminish" (quote ("use-package-normalize-diminish")))) (autoload (quote use-package-normalize/:ensure) "use-package-ensure" "

(fn NAME KEYWORD ARGS)" nil nil) (autoload (quote use-package-handler/:ensure) "use-package-ensure" "

(fn NAME KEYWORD ENSURE REST STATE)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "use-package-ensure" (quote ("use-package-")))) (autoload (quote use-package-jump-to-package-form) "use-package-jump" "Attempt to find and jump to the `use-package' form that loaded
PACKAGE. This will only find the form if that form actually
required PACKAGE. If PACKAGE was previously required then this
function will jump to the file that originally required PACKAGE
instead.

(fn PACKAGE)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "use-package-jump" (quote ("use-package-find-require")))) (autoload (quote use-package-lint) "use-package-lint" "Check for errors in use-package declarations.
For example, if the module's `:if' condition is met, but even
with the specified `:load-path' the module cannot be found.

(fn)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "use-package-lint" (quote ("use-package-lint-declaration")))) (provide (quote use-package-autoloads))) "goto-chg" ((goto-chg goto-chg-autoloads) (autoload (quote goto-last-change) "goto-chg" "Go to the point where the last edit was made in the current buffer.
Repeat the command to go to the second last edit, etc.

To go back to more recent edit, the reverse of this command, use \\[goto-last-change-reverse]
or precede this command with \\[universal-argument] - (minus).

It does not go to the same point twice even if there has been many edits
there. I call the minimal distance between distinguishable edits \"span\".
Set variable `glc-default-span' to control how close is \"the same point\".
Default span is 8.
The span can be changed temporarily with \\[universal-argument] right before \\[goto-last-change]:
\\[universal-argument] <NUMBER> set current span to that number,
\\[universal-argument] (no number) multiplies span by 4, starting with default.
The so set span remains until it is changed again with \\[universal-argument], or the consecutive
repetition of this command is ended by any other command.

When span is zero (i.e. \\[universal-argument] 0) subsequent \\[goto-last-change] visits each and
every point of edit and a message shows what change was made there.
In this case it may go to the same point twice.

This command uses undo information. If undo is disabled, so is this command.
At times, when undo information becomes too large, the oldest information is
discarded. See variable `undo-limit'.

(fn ARG)" t nil) (autoload (quote goto-last-change-reverse) "goto-chg" "Go back to more recent changes after \\[goto-last-change] have been used.
See `goto-last-change' for use of prefix argument.

(fn ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "goto-chg" (quote ("glc-")))) (provide (quote goto-chg-autoloads))) "evil" ((evil-pkg evil-common evil-commands evil-macros evil-maps evil-search evil-repeat evil-integration evil-ex evil-command-window evil evil-states evil-development evil-autoloads evil-jumps evil-core evil-types evil-keybindings evil-vars evil-digraphs) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-command-window" (quote ("evil-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-commands" (quote ("evil-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-common" (quote ("evil-" "forward-evil-" "bounds-of-evil-")))) (autoload (quote evil-mode) "evil" nil t) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-core" (quote ("evil-" "turn-o")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-digraphs" (quote ("evil-digraph")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-ex" (quote ("evil-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-integration" (quote ("evil-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-jumps" (quote ("evil-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-macros" (quote ("evil-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-maps" (quote ("evil-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-repeat" (quote ("evil-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-search" (quote ("evil-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-states" (quote ("evil-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-types" (quote ("evil-ex-get-optional-register-and-count")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-vars" (quote ("evil-")))) (provide (quote evil-autoloads))) "annalist" ((annalist-autoloads annalist) (autoload (quote annalist-record) "annalist" "In the store for ANNALIST, TYPE, and LOCAL, record RECORD.
ANNALIST should correspond to the package/user recording this information (e.g.
'general, 'me, etc.). TYPE is the type of information being recorded (e.g.
'keybindings). LOCAL corresponds to whether to store RECORD only for the current
buffer. This information together is used to select where RECORD should be
stored in and later retrieved from with `annalist-describe'. RECORD should be a
list of items to record and later print as org headings and column entries in a
single row. If PLIST is non-nil, RECORD should be a plist instead of an ordered
list (e.g. '(keymap org-mode-map key \"C-c a\" ...)). The plist keys should be
the symbols used for the definition of TYPE.

(fn ANNALIST TYPE RECORD &key LOCAL PLIST)" nil nil) (autoload (quote annalist-describe) "annalist" "Describe information recorded by ANNALIST for TYPE.
For example: (annalist-describe 'general 'keybindings) If VIEW is non-nil, use
those settings for displaying recorded information instead of the defaults.

(fn ANNALIST TYPE &optional VIEW)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "annalist" (quote ("annalist-")))) (provide (quote annalist-autoloads))) "evil-collection" ((evil-collection-autoloads evil-collection) (autoload (quote evil-collection-translate-key) "evil-collection" "Translate keys in the keymap(s) corresponding to STATES and KEYMAPS.
STATES should be the name of an evil state, a list of states, or nil. KEYMAPS
should be a symbol corresponding to the keymap to make the translations in or a
list of keymap symbols. Like `evil-define-key', when a keymap does not exist,
the keybindings will be deferred until the keymap is defined, so
`with-eval-after-load' is not necessary. TRANSLATIONS corresponds to a list of
key replacement pairs. For example, specifying \"a\" \"b\" will bind \"a\" to
\"b\"'s definition in the keymap. Specifying nil as a replacement will unbind a
key. If DESTRUCTIVE is nil, a backup of the keymap will be stored on the initial
invocation, and future invocations will always look up keys in the backup
keymap. When no TRANSLATIONS are given, this function will only create the
backup keymap without making any translations. On the other hand, if DESTRUCTIVE
is non-nil, the keymap will be destructively altered without creating a backup.
For example, calling this function multiple times with \"a\" \"b\" \"b\" \"a\"
would continue to swap and unswap the definitions of these keys. This means that
when DESTRUCTIVE is non-nil, all related swaps/cycles should be done in the same
invocation.

(fn STATES KEYMAPS &rest TRANSLATIONS &key DESTRUCTIVE &allow-other-keys)" nil nil) (function-put (quote evil-collection-translate-key) (quote lisp-indent-function) (quote defun)) (autoload (quote evil-collection-swap-key) "evil-collection" "Wrapper around `evil-collection-translate-key' for swapping keys.
STATES, KEYMAPS, and ARGS are passed to `evil-collection-translate-key'. ARGS
should consist of key swaps (e.g. \"a\" \"b\" is equivalent to \"a\" \"b\" \"b\"
\"a\" with `evil-collection-translate-key') and optionally keyword arguments for
`evil-collection-translate-key'.

(fn STATES KEYMAPS &rest ARGS)" nil t) (function-put (quote evil-collection-swap-key) (quote lisp-indent-function) (quote defun)) (autoload (quote evil-collection-require) "evil-collection" "Require the evil-collection-MODE file, but do not activate it.

MODE should be a symbol. This requires the evil-collection-MODE
feature without needing to manipulate `load-path'. NOERROR is
forwarded to `require'.

(fn MODE &optional NOERROR)" nil nil) (autoload (quote evil-collection-init) "evil-collection" "Register the Evil bindings for all modes in `evil-collection-mode-list'.

Alternatively, you may register select bindings manually, for
instance:

  (with-eval-after-load 'calendar
    (evil-collection-calendar-setup))

If MODES is specified (as either one mode or a list of modes), use those modes
instead of the modes in `evil-collection-mode-list'.

(fn &optional MODES)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-collection" (quote ("evil-collection-")))) (provide (quote evil-collection-autoloads))) "dash" ((dash dash-autoloads) (autoload (quote dash-fontify-mode) "dash" "Toggle fontification of Dash special variables.

Dash-Fontify mode is a buffer-local minor mode intended for Emacs
Lisp buffers.  Enabling it causes the special variables bound in
anaphoric Dash macros to be fontified.  These anaphoras include
`it', `it-index', `acc', and `other'.  In older Emacs versions
which do not dynamically detect macros, Dash-Fontify mode
additionally fontifies Dash macro calls.

See also `dash-fontify-mode-lighter' and
`global-dash-fontify-mode'.

(fn &optional ARG)" t nil) (defvar global-dash-fontify-mode nil "Non-nil if Global Dash-Fontify mode is enabled.
See the `global-dash-fontify-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-dash-fontify-mode'.") (custom-autoload (quote global-dash-fontify-mode) "dash" nil) (autoload (quote global-dash-fontify-mode) "dash" "Toggle Dash-Fontify mode in all buffers.
With prefix ARG, enable Global Dash-Fontify mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Dash-Fontify mode is enabled in all buffers where
`dash--turn-on-fontify-mode' would do it.
See `dash-fontify-mode' for more information on Dash-Fontify mode.

(fn &optional ARG)" t nil) (autoload (quote dash-register-info-lookup) "dash" "Register the Dash Info manual with `info-lookup-symbol'.
This allows Dash symbols to be looked up with \\[info-lookup-symbol].

(fn)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "dash" (quote ("dash-" "-keep" "-butlast" "-zip" "-e" "->" "-gr" "-when-let" "-d" "-l" "-s" "-m" "-u" "-value-to-list" "-t" "--" "-juxt" "-r" "-no" "-o" "-a" "-i" "-c" "-f" "-p" "!cons" "!cdr")))) (provide (quote dash-autoloads))) "solarized-theme" ((solarized-theme-utils solarized-faces solarized-dark-high-contrast-theme solarized-dark-theme solarized-wombat-dark-theme solarized-gruvbox-light-theme solarized-theme-autoloads solarized-theme solarized-zenburn-theme solarized-palettes solarized-gruvbox-dark-theme solarized solarized-light-high-contrast-theme solarized-light-theme) (autoload (quote solarized-color-blend) "solarized" "Blends COLOR1 onto COLOR2 with ALPHA.

COLOR1 and COLOR2 should be color names (e.g. \"white\") or RGB
triplet strings (e.g. \"#ff12ec\").

Alpha should be a float between 0 and 1.

Optional argument DIGITS-PER-COMPONENT can be either 4 (the default) or 2;
use the latter if you need a 24-bit specification of a color.

(fn COLOR1 COLOR2 ALPHA &optional DIGITS-PER-COMPONENT)" nil nil) (autoload (quote solarized-create-color-palette) "solarized" "Create color-palette from CORE-PALETTE.

The Returned color-palette has the same format as `solarized-color-palette'

(fn CORE-PALETTE)" nil nil) (when (and (boundp (quote custom-theme-load-path)) load-file-name) (add-to-list (quote custom-theme-load-path) (file-name-as-directory (file-name-directory load-file-name)))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "solarized" (quote ("solarized-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "solarized-dark-high-contrast-theme" (quote ("solarized-dark-high-contrast")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "solarized-dark-theme" (quote ("solarized-dark")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "solarized-faces" (quote ("solarized-definition")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "solarized-gruvbox-dark-theme" (quote ("solarized-gruvbox-dark")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "solarized-gruvbox-light-theme" (quote ("solarized-gruvbox-light")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "solarized-light-high-contrast-theme" (quote ("solarized-light-high-contrast")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "solarized-light-theme" (quote ("solarized-light")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "solarized-palettes" (quote ("solarized-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "solarized-theme-utils" (quote ("solarized-import-faces")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "solarized-wombat-dark-theme" (quote ("solarized-wombat-dark")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "solarized-zenburn-theme" (quote ("solarized-zenburn")))) (provide (quote solarized-theme-autoloads))) "better-jumper" ((better-jumper-autoloads better-jumper) (autoload (quote better-jumper-set-jump) "better-jumper" "Set jump point at POS.
POS defaults to point.

(fn &optional POS)" nil nil) (autoload (quote better-jumper-jump-backward) "better-jumper" "Jump backward COUNT positions to previous location in jump list.
If COUNT is nil then defaults to 1.

(fn &optional COUNT)" t nil) (autoload (quote better-jumper-jump-forward) "better-jumper" "Jump forward COUNT positions to location in jump list.
If COUNT is nil then defaults to 1.

(fn &optional COUNT)" t nil) (autoload (quote better-jumper-jump-newest) "better-jumper" "Jump forward to newest entry in jump list.

(fn)" t nil) (autoload (quote better-jumper-clear-jumps) "better-jumper" "Clears jump list for WINDOW-OR-BUFFER.
WINDOW-OR-BUFFER should be either a window or buffer depending on the
context and will default to current context if not provided.

(fn &optional WINDOW-OR-BUFFER)" nil nil) (autoload (quote better-jumper-get-jumps) "better-jumper" "Get jumps for WINDOW-OR-BUFFER.
WINDOW-OR-BUFFER should be either a window or buffer depending on the
context and will default to current context if not provided.

(fn &optional WINDOW-OR-BUFFER)" nil nil) (autoload (quote better-jumper-set-jumps) "better-jumper" "Set jumps to JUMPS for WINDOW-OR-BUFFER.
WINDOW-OR-BUFFER should be either a window or buffer depending on the
context and will default to current context if not provided.

(fn JUMPS &optional WINDOW-OR-BUFFER)" nil nil) (autoload (quote turn-on-better-jumper-mode) "better-jumper" "Enable better-jumper-mode in the current buffer.

(fn)" nil nil) (autoload (quote turn-off-better-jumper-mode) "better-jumper" "Disable `better-jumper-local-mode' in the current buffer.

(fn)" nil nil) (autoload (quote better-jumper-local-mode) "better-jumper" "better-jumper minor mode.

(fn &optional ARG)" t nil) (defvar better-jumper-mode nil "Non-nil if Better-Jumper mode is enabled.
See the `better-jumper-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `better-jumper-mode'.") (custom-autoload (quote better-jumper-mode) "better-jumper" nil) (autoload (quote better-jumper-mode) "better-jumper" "Toggle Better-Jumper-Local mode in all buffers.
With prefix ARG, enable Better-Jumper mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Better-Jumper-Local mode is enabled in all buffers where
`turn-on-better-jumper-mode' would do it.
See `better-jumper-local-mode' for more information on Better-Jumper-Local mode.

(fn &optional ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "better-jumper" (quote ("better-jumper-")))) (provide (quote better-jumper-autoloads))) "neotree" ((neotree-autoloads neotree) (autoload (quote neotree-find) "neotree" "Quick select node which specified PATH in NeoTree.
If path is nil and no buffer file name, then use DEFAULT-PATH,

(fn &optional PATH DEFAULT-PATH)" t nil) (autoload (quote neotree-projectile-action) "neotree" "Integration with `Projectile'.

Usage:
    (setq projectile-switch-project-action 'neotree-projectile-action).

When running `projectile-switch-project' (C-c p p), `neotree' will change root
automatically.

(fn)" t nil) (autoload (quote neotree-toggle) "neotree" "Toggle show the NeoTree window.

(fn)" t nil) (autoload (quote neotree-show) "neotree" "Show the NeoTree window.

(fn)" t nil) (autoload (quote neotree-hide) "neotree" "Close the NeoTree window.

(fn)" t nil) (autoload (quote neotree-dir) "neotree" "Show the NeoTree window, and change root to PATH.

(fn PATH)" t nil) (defalias (quote neotree) (quote neotree-show) "Show the NeoTree window.") (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "neotree" (quote ("neo" "off-p")))) (provide (quote neotree-autoloads))) "all-the-icons" ((all-the-icons all-the-icons-autoloads all-the-icons-faces) (autoload (quote all-the-icons-icon-for-dir) "all-the-icons" "Get the formatted icon for DIR.
ARG-OVERRIDES should be a plist containining `:height',
`:v-adjust' or `:face' properties like in the normal icon
inserting functions.

Note: You want chevron, please use `all-the-icons-icon-for-dir-with-chevron'.

(fn DIR &rest ARG-OVERRIDES)" nil nil) (autoload (quote all-the-icons-icon-for-file) "all-the-icons" "Get the formatted icon for FILE.
ARG-OVERRIDES should be a plist containining `:height',
`:v-adjust' or `:face' properties like in the normal icon
inserting functions.

(fn FILE &rest ARG-OVERRIDES)" nil nil) (autoload (quote all-the-icons-icon-for-mode) "all-the-icons" "Get the formatted icon for MODE.
ARG-OVERRIDES should be a plist containining `:height',
`:v-adjust' or `:face' properties like in the normal icon
inserting functions.

(fn MODE &rest ARG-OVERRIDES)" nil nil) (autoload (quote all-the-icons-icon-for-url) "all-the-icons" "Get the formatted icon for URL.
If an icon for URL isn't found in `all-the-icons-url-alist', a globe is used.
ARG-OVERRIDES should be a plist containining `:height',
`:v-adjust' or `:face' properties like in the normal icon
inserting functions.

(fn URL &rest ARG-OVERRIDES)" nil nil) (autoload (quote all-the-icons-install-fonts) "all-the-icons" "Helper function to download and install the latests fonts based on OS.
When PFX is non-nil, ignore the prompt and just install

(fn &optional PFX)" t nil) (autoload (quote all-the-icons-insert) "all-the-icons" "Interactive icon insertion function.
When Prefix ARG is non-nil, insert the propertized icon.
When FAMILY is non-nil, limit the candidates to the icon set matching it.

(fn &optional ARG FAMILY)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "all-the-icons" (quote ("all-the-icons-")))) (provide (quote all-the-icons-autoloads))) "avy" ((avy-autoloads avy) (autoload (quote avy-process) "avy" "Select one of CANDIDATES using `avy-read'.
Use OVERLAY-FN to visualize the decision overlay.
CLEANUP-FN should take no arguments and remove the effects of
multiple OVERLAY-FN invocations.

(fn CANDIDATES &optional OVERLAY-FN CLEANUP-FN)" nil nil) (autoload (quote avy-goto-char) "avy" "Jump to the currently visible CHAR.
The window scope is determined by `avy-all-windows' (ARG negates it).

(fn CHAR &optional ARG)" t nil) (autoload (quote avy-goto-char-in-line) "avy" "Jump to the currently visible CHAR in the current line.

(fn CHAR)" t nil) (autoload (quote avy-goto-char-2) "avy" "Jump to the currently visible CHAR1 followed by CHAR2.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.
BEG and END narrow the scope where candidates are searched.

(fn CHAR1 CHAR2 &optional ARG BEG END)" t nil) (autoload (quote avy-goto-char-2-above) "avy" "Jump to the currently visible CHAR1 followed by CHAR2.
This is a scoped version of `avy-goto-char-2', where the scope is
the visible part of the current buffer up to point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

(fn CHAR1 CHAR2 &optional ARG)" t nil) (autoload (quote avy-goto-char-2-below) "avy" "Jump to the currently visible CHAR1 followed by CHAR2.
This is a scoped version of `avy-goto-char-2', where the scope is
the visible part of the current buffer following point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

(fn CHAR1 CHAR2 &optional ARG)" t nil) (autoload (quote avy-isearch) "avy" "Jump to one of the current isearch candidates.

(fn)" t nil) (autoload (quote avy-goto-word-0) "avy" "Jump to a word start.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.
BEG and END narrow the scope where candidates are searched.

(fn ARG &optional BEG END)" t nil) (autoload (quote avy-goto-whitespace-end) "avy" "Jump to the end of a whitespace sequence.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.
BEG and END narrow the scope where candidates are searched.

(fn ARG &optional BEG END)" t nil) (autoload (quote avy-goto-word-1) "avy" "Jump to the currently visible CHAR at a word start.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.
BEG and END narrow the scope where candidates are searched.
When SYMBOL is non-nil, jump to symbol start instead of word start.

(fn CHAR &optional ARG BEG END SYMBOL)" t nil) (autoload (quote avy-goto-word-1-above) "avy" "Jump to the currently visible CHAR at a word start.
This is a scoped version of `avy-goto-word-1', where the scope is
the visible part of the current buffer up to point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

(fn CHAR &optional ARG)" t nil) (autoload (quote avy-goto-word-1-below) "avy" "Jump to the currently visible CHAR at a word start.
This is a scoped version of `avy-goto-word-1', where the scope is
the visible part of the current buffer following point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

(fn CHAR &optional ARG)" t nil) (autoload (quote avy-goto-symbol-1) "avy" "Jump to the currently visible CHAR at a symbol start.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

(fn CHAR &optional ARG)" t nil) (autoload (quote avy-goto-symbol-1-above) "avy" "Jump to the currently visible CHAR at a symbol start.
This is a scoped version of `avy-goto-symbol-1', where the scope is
the visible part of the current buffer up to point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

(fn CHAR &optional ARG)" t nil) (autoload (quote avy-goto-symbol-1-below) "avy" "Jump to the currently visible CHAR at a symbol start.
This is a scoped version of `avy-goto-symbol-1', where the scope is
the visible part of the current buffer following point.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

(fn CHAR &optional ARG)" t nil) (autoload (quote avy-goto-subword-0) "avy" "Jump to a word or subword start.
The window scope is determined by `avy-all-windows' (ARG negates it).

When PREDICATE is non-nil it's a function of zero parameters that
should return true.

BEG and END narrow the scope where candidates are searched.

(fn &optional ARG PREDICATE BEG END)" t nil) (autoload (quote avy-goto-subword-1) "avy" "Jump to the currently visible CHAR at a subword start.
The window scope is determined by `avy-all-windows' (ARG negates it).
The case of CHAR is ignored.

(fn CHAR &optional ARG)" t nil) (autoload (quote avy-goto-word-or-subword-1) "avy" "Forward to `avy-goto-subword-1' or `avy-goto-word-1'.
Which one depends on variable `subword-mode'.

(fn)" t nil) (autoload (quote avy-goto-line) "avy" "Jump to a line start in current buffer.

When ARG is 1, jump to lines currently visible, with the option
to cancel to `goto-line' by entering a number.

When ARG is 4, negate the window scope determined by
`avy-all-windows'.

Otherwise, forward to `goto-line' with ARG.

(fn &optional ARG)" t nil) (autoload (quote avy-goto-line-above) "avy" "Goto visible line above the cursor.
OFFSET changes the distance between the closest key to the cursor and
the cursor
When BOTTOM-UP is non-nil, display avy candidates from top to bottom

(fn &optional OFFSET BOTTOM-UP)" t nil) (autoload (quote avy-goto-line-below) "avy" "Goto visible line below the cursor.
OFFSET changes the distance between the closest key to the cursor and
the cursor
When BOTTOM-UP is non-nil, display avy candidates from top to bottom

(fn &optional OFFSET BOTTOM-UP)" t nil) (autoload (quote avy-goto-end-of-line) "avy" "Call `avy-goto-line' and move to the end of the line.

(fn &optional ARG)" t nil) (autoload (quote avy-copy-line) "avy" "Copy a selected line above the current line.
ARG lines can be used.

(fn ARG)" t nil) (autoload (quote avy-move-line) "avy" "Move a selected line above the current line.
ARG lines can be used.

(fn ARG)" t nil) (autoload (quote avy-copy-region) "avy" "Select two lines and copy the text between them to point.

The window scope is determined by `avy-all-windows' or
`avy-all-windows-alt' when ARG is non-nil.

(fn ARG)" t nil) (autoload (quote avy-move-region) "avy" "Select two lines and move the text between them above the current line.

(fn)" t nil) (autoload (quote avy-kill-region) "avy" "Select two lines and kill the region between them.

The window scope is determined by `avy-all-windows' or
`avy-all-windows-alt' when ARG is non-nil.

(fn ARG)" t nil) (autoload (quote avy-kill-ring-save-region) "avy" "Select two lines and save the region between them to the kill ring.
The window scope is determined by `avy-all-windows'.
When ARG is non-nil, do the opposite of `avy-all-windows'.

(fn ARG)" t nil) (autoload (quote avy-kill-whole-line) "avy" "Select line and kill the whole selected line.

With a numerical prefix ARG, kill ARG line(s) starting from the
selected line.  If ARG is negative, kill backward.

If ARG is zero, kill the selected line but exclude the trailing
newline.

\\[universal-argument] 3 \\[avy-kil-whole-line] kill three lines
starting from the selected line.  \\[universal-argument] -3

\\[avy-kill-whole-line] kill three lines backward including the
selected line.

(fn ARG)" t nil) (autoload (quote avy-kill-ring-save-whole-line) "avy" "Select line and save the whole selected line as if killed, but don\342\200\231t kill it.

This command is similar to `avy-kill-whole-line', except that it
saves the line(s) as if killed, but does not kill it(them).

With a numerical prefix ARG, kill ARG line(s) starting from the
selected line.  If ARG is negative, kill backward.

If ARG is zero, kill the selected line but exclude the trailing
newline.

(fn ARG)" t nil) (autoload (quote avy-setup-default) "avy" "Setup the default shortcuts.

(fn)" nil nil) (autoload (quote avy-goto-char-timer) "avy" "Read one or many consecutive chars and jump to the first one.
The window scope is determined by `avy-all-windows' (ARG negates it).

(fn &optional ARG)" t nil) (autoload (quote avy-transpose-lines-in-region) "avy" "Transpose lines in the active region.

(fn)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "avy" (quote ("avy-")))) (provide (quote avy-autoloads))) "ace-window" ((ace-window-autoloads ace-window) (autoload (quote ace-select-window) "ace-window" "Ace select window.

(fn)" t nil) (autoload (quote ace-delete-window) "ace-window" "Ace delete window.

(fn)" t nil) (autoload (quote ace-swap-window) "ace-window" "Ace swap window.

(fn)" t nil) (autoload (quote ace-delete-other-windows) "ace-window" "Ace delete other windows.

(fn)" t nil) (autoload (quote ace-display-buffer) "ace-window" "Make `display-buffer' and `pop-to-buffer' select using `ace-window'.
See sample config for `display-buffer-base-action' and `display-buffer-alist':
https://github.com/abo-abo/ace-window/wiki/display-buffer.

(fn BUFFER ALIST)" nil nil) (autoload (quote ace-window) "ace-window" "Select a window.
Perform an action based on ARG described below.

By default, behaves like extended `other-window'.
See `aw-scope' which extends it to work with frames.

Prefixed with one \\[universal-argument], does a swap between the
selected window and the current window, so that the selected
buffer moves to current window (and current buffer moves to
selected window).

Prefixed with two \\[universal-argument]'s, deletes the selected
window.

(fn ARG)" t nil) (defvar ace-window-display-mode nil "Non-nil if Ace-Window-Display mode is enabled.
See the `ace-window-display-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `ace-window-display-mode'.") (custom-autoload (quote ace-window-display-mode) "ace-window" nil) (autoload (quote ace-window-display-mode) "ace-window" "Minor mode for showing the ace window key in the mode line.

(fn &optional ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "ace-window" (quote ("ace-window-mode" "aw-")))) (provide (quote ace-window-autoloads))) "powerline" ((powerline-separators powerline-autoloads powerline powerline-themes) (autoload (quote powerline-hud) "powerline" "Return an XPM of relative buffer location using FACE1 and FACE2 of optional WIDTH.

(fn FACE1 FACE2 &optional WIDTH)" nil nil) (autoload (quote powerline-mouse) "powerline" "Return mouse handler for CLICK-GROUP given CLICK-TYPE and STRING.

(fn CLICK-GROUP CLICK-TYPE STRING)" nil nil) (autoload (quote powerline-concat) "powerline" "Concatonate STRINGS and pad sides by spaces.

(fn &rest STRINGS)" nil nil) (autoload (quote defpowerline) "powerline" "Create function NAME by wrapping BODY with powerline padding an propetization.

(fn NAME BODY)" nil t) (autoload (quote powerline-raw) "powerline" "Render STR as mode-line data using FACE and optionally PAD import on left (l) or right (r).

(fn STR &optional FACE PAD)" nil nil) (autoload (quote powerline-fill) "powerline" "Return empty space using FACE and leaving RESERVE space on the right.

(fn FACE RESERVE)" nil nil) (autoload (quote powerline-major-mode) "powerline") (autoload (quote powerline-minor-modes) "powerline") (autoload (quote powerline-narrow) "powerline") (autoload (quote powerline-vc) "powerline") (autoload (quote powerline-encoding) "powerline") (autoload (quote powerline-buffer-size) "powerline") (autoload (quote powerline-buffer-id) "powerline") (autoload (quote powerline-process) "powerline") (autoload (quote powerline-selected-window-active) "powerline") (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "powerline" (quote ("pl/" "powerline-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "powerline-separators" (quote ("powerline-image-apple-rgb" "pl/")))) (autoload (quote powerline-default-theme) "powerline-themes" "Setup the default mode-line.

(fn)" t nil) (autoload (quote powerline-center-theme) "powerline-themes" "Setup a mode-line with major and minor modes centered.

(fn)" t nil) (autoload (quote powerline-vim-theme) "powerline-themes" "Setup a Vim-like mode-line.

(fn)" t nil) (autoload (quote powerline-nano-theme) "powerline-themes" "Setup a nano-like mode-line.

(fn)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "powerline-themes" (quote ("powerline-")))) (provide (quote powerline-autoloads))) "airline-themes" ((airline-jet-theme airline-papercolor-theme airline-base16_default-theme airline-base16_snazzy-theme airline-base16_atelierlakeside-theme airline-base16_paraiso-theme airline-wombat-theme airline-base16_mocha-theme airline-doom-molokai-theme airline-base16_atelierforest-theme airline-base16_3024-theme airline-base16-theme airline-biogoo-theme airline-base16-gui-dark-theme airline-ayu_mirage-theme airline-hybridline-theme airline-qwq-theme airline-murmur-theme airline-luna-theme airline-base16_solarized-theme airline-solarized-gui-theme airline-doom-one-theme airline-ouo-theme airline-behelit-theme airline-kalisi-theme airline-base16_greenscreen-theme airline-light-theme airline-minimalist-theme airline-base16_colors-theme airline-base16_grayscale-theme airline-desertink-theme airline-themes airline-base16-shell-dark-theme airline-base16_chalk-theme airline-solarized_flood-theme airline-onedark-theme airline-base16_bright-theme airline-raven-theme airline-peaksea-theme airline-base16_embers-theme airline-violet-theme airline-simple-theme airline-sol-theme airline-durant-theme airline-base16_ocean-theme airline-xtermlight-theme airline-base16_atelierheath-theme airline-solarized-theme airline-base16_twilight-theme airline-base16_nord-theme airline-badwolf-theme airline-term_light-theme airline-base16_shapeshifter-theme airline-night_owl-theme airline-base16_isotope-theme airline-ayu_dark-theme airline-zenburn-theme airline-hybrid-theme airline-base16_classic-theme airline-base16_monokai-theme airline-fruit_punch-theme airline-serene-theme airline-laederon-theme airline-base16_pop-theme airline-base16_bespin-theme airline-deus-theme airline-gruvbox-dark-theme airline-base16_spacemacs-theme airline-ubaryd-theme airline-jellybeans-theme airline-themes-autoloads airline-base16_adwaita-theme airline-bubblegum-theme airline-base16_ashes-theme airline-ayu_light-theme airline-monochrome-theme airline-base16_railscasts-theme airline-silver-theme airline-base16_brewer-theme airline-base16_atelierseaside-theme airline-understated-theme airline-soda-theme airline-molokai-theme airline-base16_oceanicnext-theme airline-sierra-theme airline-cool-theme airline-dark_minimal-theme airline-fairyfloss-theme airline-solarized-alternate-gui-theme airline-distinguished-theme airline-dark-theme airline-term-theme airline-ravenpower-theme airline-base16_gruvbox_dark_hard-theme airline-base16_shell-theme airline-base16_atelierdune-theme airline-alduin-theme airline-base16_summerfruit-theme airline-atomic-theme airline-base16_tomorrow-theme airline-base16_harmonic16-theme airline-lucius-theme airline-base16_flat-theme airline-seagull-theme airline-owo-theme airline-base16_vim-theme airline-kolor-theme airline-base16_londontube-theme airline-cobalt2-theme airline-tomorrow-theme airline-base16_seti-theme airline-base16_codeschool-theme airline-base16-gui-light-theme airline-angr-theme airline-base16_marrakesh-theme airline-powerlineish-theme airline-base16_google-theme airline-base16_apathy-theme airline-base16color-theme airline-base16_hopscotch-theme airline-base16_eighties-theme) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-alduin-theme" (quote ("airline-alduin")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-angr-theme" (quote ("airline-angr")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-atomic-theme" (quote ("airline-atomic")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-ayu_dark-theme" (quote ("airline-ayu_dark")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-ayu_light-theme" (quote ("airline-ayu_light")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-ayu_mirage-theme" (quote ("airline-ayu_mirage")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-badwolf-theme" (quote ("airline-badwolf")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16-gui-dark-theme" (quote ("airline-base16-gui-dark")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16-gui-light-theme" (quote ("airline-base16-gui-light")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16-shell-dark-theme" (quote ("airline-base16-shell-dark")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16-theme" (quote ("airline-base16")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_3024-theme" (quote ("airline-base16_3024")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_adwaita-theme" (quote ("airline-base16_adwaita")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_apathy-theme" (quote ("airline-base16_apathy")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_ashes-theme" (quote ("airline-base16_ashes")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_atelierdune-theme" (quote ("airline-base16_atelierdune")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_atelierforest-theme" (quote ("airline-base16_atelierforest")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_atelierheath-theme" (quote ("airline-base16_atelierheath")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_atelierlakeside-theme" (quote ("airline-base16_atelierlakeside")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_atelierseaside-theme" (quote ("airline-base16_atelierseaside")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_bespin-theme" (quote ("airline-base16_bespin")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_brewer-theme" (quote ("airline-base16_brewer")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_bright-theme" (quote ("airline-base16_bright")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_chalk-theme" (quote ("airline-base16_chalk")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_classic-theme" (quote ("airline-base16_classic")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_codeschool-theme" (quote ("airline-base16_codeschool")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_colors-theme" (quote ("airline-base16_colors")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_default-theme" (quote ("airline-base16_default")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_eighties-theme" (quote ("airline-base16_eighties")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_embers-theme" (quote ("airline-base16_embers")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_flat-theme" (quote ("airline-base16_flat")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_google-theme" (quote ("airline-base16_google")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_grayscale-theme" (quote ("airline-base16_grayscale")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_greenscreen-theme" (quote ("airline-base16_greenscreen")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_gruvbox_dark_hard-theme" (quote ("airline-base16_gruvbox_dark_hard")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_harmonic16-theme" (quote ("airline-base16_harmonic16")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_hopscotch-theme" (quote ("airline-base16_hopscotch")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_isotope-theme" (quote ("airline-base16_isotope")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_londontube-theme" (quote ("airline-base16_londontube")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_marrakesh-theme" (quote ("airline-base16_marrakesh")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_mocha-theme" (quote ("airline-base16_mocha")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_monokai-theme" (quote ("airline-base16_monokai")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_nord-theme" (quote ("airline-base16_nord")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_ocean-theme" (quote ("airline-base16_ocean")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_oceanicnext-theme" (quote ("airline-base16_oceanicnext")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_paraiso-theme" (quote ("airline-base16_paraiso")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_pop-theme" (quote ("airline-base16_pop")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_railscasts-theme" (quote ("airline-base16_railscasts")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_seti-theme" (quote ("airline-base16_seti")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_shapeshifter-theme" (quote ("airline-base16_shapeshifter")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_shell-theme" (quote ("airline-base16_shell")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_snazzy-theme" (quote ("airline-base16_snazzy")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_solarized-theme" (quote ("airline-base16_solarized")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_spacemacs-theme" (quote ("airline-base16_spacemacs")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_summerfruit-theme" (quote ("airline-base16_summerfruit")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_tomorrow-theme" (quote ("airline-base16_tomorrow")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_twilight-theme" (quote ("airline-base16_twilight")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16_vim-theme" (quote ("airline-base16_vim")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-base16color-theme" (quote ("airline-base16color")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-behelit-theme" (quote ("airline-behelit")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-biogoo-theme" (quote ("airline-biogoo")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-bubblegum-theme" (quote ("airline-bubblegum")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-cobalt2-theme" (quote ("airline-cobalt2")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-cool-theme" (quote ("airline-cool")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-dark-theme" (quote ("airline-dark")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-dark_minimal-theme" (quote ("airline-dark_minimal")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-desertink-theme" (quote ("airline-desertink")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-deus-theme" (quote ("airline-deus")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-distinguished-theme" (quote ("airline-distinguished")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-doom-molokai-theme" (quote ("airline-doom-molokai")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-doom-one-theme" (quote ("airline-doom-one")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-durant-theme" (quote ("airline-durant")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-fairyfloss-theme" (quote ("airline-fairyfloss")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-fruit_punch-theme" (quote ("airline-fruit_punch")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-gruvbox-dark-theme" (quote ("airline-gruvbox-dark")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-hybrid-theme" (quote ("airline-hybrid")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-hybridline-theme" (quote ("airline-hybridline")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-jellybeans-theme" (quote ("airline-jellybeans")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-jet-theme" (quote ("airline-jet")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-kalisi-theme" (quote ("airline-kalisi")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-kolor-theme" (quote ("airline-kolor")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-laederon-theme" (quote ("airline-laederon")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-light-theme" (quote ("airline-light")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-lucius-theme" (quote ("airline-lucius")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-luna-theme" (quote ("airline-luna")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-minimalist-theme" (quote ("airline-minimalist")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-molokai-theme" (quote ("airline-molokai")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-monochrome-theme" (quote ("airline-monochrome")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-murmur-theme" (quote ("airline-murmur")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-night_owl-theme" (quote ("airline-night_owl")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-onedark-theme" (quote ("airline-onedark")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-ouo-theme" (quote ("airline-ouo")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-owo-theme" (quote ("airline-owo")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-papercolor-theme" (quote ("airline-papercolor")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-peaksea-theme" (quote ("airline-peaksea")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-powerlineish-theme" (quote ("airline-powerlineish")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-qwq-theme" (quote ("airline-qwq")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-raven-theme" (quote ("airline-raven")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-ravenpower-theme" (quote ("airline-ravenpower")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-seagull-theme" (quote ("airline-seagull")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-serene-theme" (quote ("airline-serene")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-sierra-theme" (quote ("airline-sierra")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-silver-theme" (quote ("airline-silver")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-simple-theme" (quote ("airline-simple")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-soda-theme" (quote ("airline-soda")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-sol-theme" (quote ("airline-sol")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-solarized-alternate-gui-theme" (quote ("airline-solarized-alternate-gui")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-solarized-gui-theme" (quote ("airline-solarized-gui")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-solarized-theme" (quote ("airline-solarized")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-solarized_flood-theme" (quote ("airline-solarized_flood")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-term-theme" (quote ("airline-term")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-term_light-theme" (quote ("airline-term_light")))) (when load-file-name (add-to-list (quote custom-theme-load-path) (file-name-as-directory (file-name-directory load-file-name)))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-themes" (quote ("airline-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-tomorrow-theme" (quote ("airline-tomorrow")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-ubaryd-theme" (quote ("airline-ubaryd")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-understated-theme" (quote ("airline-understated")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-violet-theme" (quote ("airline-violet")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-wombat-theme" (quote ("airline-wombat")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-xtermlight-theme" (quote ("airline-xtermlight")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "airline-zenburn-theme" (quote ("airline-zenburn")))) (provide (quote airline-themes-autoloads))) "s" ((s s-autoloads) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "s" (quote ("s-")))) (provide (quote s-autoloads))) "spaceline" ((spaceline-segments spaceline spaceline-autoloads spaceline-config) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "spaceline" (quote ("spaceline-")))) (autoload (quote spaceline-spacemacs-theme) "spaceline-config" "Install the modeline used by Spacemacs.

ADDITIONAL-SEGMENTS are inserted on the right, between `global' and
`buffer-position'.

(fn &rest ADDITIONAL-SEGMENTS)" nil nil) (autoload (quote spaceline-emacs-theme) "spaceline-config" "Install a modeline close to the one used by Spacemacs, but which
looks better without third-party dependencies.

ADDITIONAL-SEGMENTS are inserted on the right, between `global' and
`buffer-position'.

(fn &rest ADDITIONAL-SEGMENTS)" nil nil) (defvar spaceline-helm-mode nil "Non-nil if Spaceline-Helm mode is enabled.
See the `spaceline-helm-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `spaceline-helm-mode'.") (custom-autoload (quote spaceline-helm-mode) "spaceline-config" nil) (autoload (quote spaceline-helm-mode) "spaceline-config" "Customize the mode-line in helm.

(fn &optional ARG)" t nil) (defvar spaceline-info-mode nil "Non-nil if Spaceline-Info mode is enabled.
See the `spaceline-info-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `spaceline-info-mode'.") (custom-autoload (quote spaceline-info-mode) "spaceline-config" nil) (autoload (quote spaceline-info-mode) "spaceline-config" "Customize the mode-line in info.
This minor mode requires info+.

(fn &optional ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "spaceline-config" (quote ("spaceline--")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "spaceline-segments" (quote ("spaceline-")))) (provide (quote spaceline-autoloads))) "rainbow-delimiters" ((rainbow-delimiters-autoloads rainbow-delimiters) (autoload (quote rainbow-delimiters-mode) "rainbow-delimiters" "Highlight nested parentheses, brackets, and braces according to their depth.

(fn &optional ARG)" t nil) (autoload (quote rainbow-delimiters-mode-enable) "rainbow-delimiters" "Enable `rainbow-delimiters-mode'.

(fn)" nil nil) (autoload (quote rainbow-delimiters-mode-disable) "rainbow-delimiters" "Disable `rainbow-delimiters-mode'.

(fn)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "rainbow-delimiters" (quote ("rainbow-delimiters-")))) (provide (quote rainbow-delimiters-autoloads))) "f" ((f f-autoloads) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "f" (quote ("f-")))) (provide (quote f-autoloads))) "undo-tree" ((undo-tree undo-tree-autoloads) (autoload (quote undo-tree-mode) "undo-tree" "Toggle undo-tree mode.
With no argument, this command toggles the mode.
A positive prefix argument turns the mode on.
A negative prefix argument turns it off.

Undo-tree-mode replaces Emacs' standard undo feature with a more
powerful yet easier to use version, that treats the undo history
as what it is: a tree.

The following keys are available in `undo-tree-mode':

  \\{undo-tree-map}

Within the undo-tree visualizer, the following keys are available:

  \\{undo-tree-visualizer-mode-map}

(fn &optional ARG)" t nil) (defvar global-undo-tree-mode nil "Non-nil if Global Undo-Tree mode is enabled.
See the `global-undo-tree-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-undo-tree-mode'.") (custom-autoload (quote global-undo-tree-mode) "undo-tree" nil) (autoload (quote global-undo-tree-mode) "undo-tree" "Toggle Undo-Tree mode in all buffers.
With prefix ARG, enable Global Undo-Tree mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Undo-Tree mode is enabled in all buffers where
`turn-on-undo-tree-mode' would do it.
See `undo-tree-mode' for more information on Undo-Tree mode.

(fn &optional ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "undo-tree" (quote ("undo-" "turn-on-undo-tree-mode" "*undo-tree-id-counter*" "buffer-undo-tree")))) (provide (quote undo-tree-autoloads))) "path-headerline-mode" ((path-headerline-mode-autoloads path-headerline-mode) (defvar path-headerline-mode nil "Non-nil if Path-Headerline mode is enabled.
See the `path-headerline-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `path-headerline-mode'.") (custom-autoload (quote path-headerline-mode) "path-headerline-mode" nil) (autoload (quote path-headerline-mode) "path-headerline-mode" "Displaying file path on headerline.

(fn &optional ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "path-headerline-mode" (quote ("ph--" "path-header-line-o")))) (provide (quote path-headerline-mode-autoloads))) "powerline-evil" ((powerline-evil-themes powerline-evil powerline-evil-autoloads) (autoload (quote powerline-evil-face) "powerline-evil" "Function to select appropriate face based on `evil-state'.

(fn)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "powerline-evil" (quote ("powerline-evil-tag")))) (autoload (quote powerline-evil-center-color-theme) "powerline-evil-themes" "Powerline's center-evil them with the evil state in color.

(fn)" t nil) (autoload (quote powerline-evil-vim-theme) "powerline-evil-themes" "Powerline's Vim-like mode-line with evil state at the beginning.

(fn)" t nil) (autoload (quote powerline-evil-vim-color-theme) "powerline-evil-themes" "Powerline's Vim-like mode-line with evil state at the beginning in color.

(fn)" t nil) (provide (quote powerline-evil-autoloads))) "evil-matchit" ((evil-matchit-terminal evil-matchit-markdown evil-matchit-fortran evil-matchit-autoloads evil-matchit-template evil-matchit-javascript evil-matchit-sh evil-matchit-diff evil-matchit-elixir evil-matchit-script evil-matchit-ocaml evil-matchit-verilog evil-matchit-cmake evil-matchit-latex evil-matchit-org evil-matchit-sdk evil-matchit-c evil-matchit-ruby evil-matchit-html evil-matchit evil-matchit-simple evil-matchit-sql evil-matchit-octave evil-matchit-python) (autoload (quote evilmi-load-plugin-rules) "evil-matchit" "Load MODES's plugin RULES.

(fn MODES RULES)" nil nil) (autoload (quote evilmi-init-plugins) "evil-matchit" "Load plugins.

(fn)" t nil) (autoload (quote evilmi-select-items) "evil-matchit" "Select NUM items/tags and the region between them.

(fn &optional NUM)" t nil) (autoload (quote evilmi-delete-items) "evil-matchit" "Delete NUM items/tags and the region between them.

(fn &optional NUM)" t nil) (autoload (quote evilmi-jump-to-percentage) "evil-matchit" "Like Vim %, NUM is the percentage of location.

(fn NUM)" t nil) (autoload (quote evilmi-jump-items) "evil-matchit" nil t) (autoload (quote evilmi-version) "evil-matchit" "Print version.

(fn)" t nil) (autoload (quote evil-matchit-mode) "evil-matchit" "Buffer-local minor mode to emulate matchit.vim.

(fn &optional ARG)" t nil) (autoload (quote turn-on-evil-matchit-mode) "evil-matchit" "Enable the minor mode in the current buffer.

(fn)" nil nil) (autoload (quote turn-off-evil-matchit-mode) "evil-matchit" "Disable the minor mode in the current buffer.

(fn)" nil nil) (defvar global-evil-matchit-mode nil "Non-nil if Global Evil-Matchit mode is enabled.
See the `global-evil-matchit-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-evil-matchit-mode'.") (custom-autoload (quote global-evil-matchit-mode) "evil-matchit" nil) (autoload (quote global-evil-matchit-mode) "evil-matchit" "Toggle Evil-Matchit mode in all buffers.
With prefix ARG, enable Global Evil-Matchit mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Evil-Matchit mode is enabled in all buffers where
`turn-on-evil-matchit-mode' would do it.
See `evil-matchit-mode' for more information on Evil-Matchit mode.

(fn &optional ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-matchit" (quote ("evil")))) (autoload (quote evilmi-c-get-tag) "evil-matchit-c" "Get tag at point.

(fn)" nil nil) (autoload (quote evilmi-c-jump) "evil-matchit-c" "Use INFO to jump NUM times.

(fn INFO NUM)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-matchit-c" (quote ("evilmi-c-")))) (autoload (quote evilmi-cmake-get-tag) "evil-matchit-cmake" "

(fn)" nil nil) (autoload (quote evilmi-cmake-jump) "evil-matchit-cmake" "

(fn INFO NUM)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-matchit-cmake" (quote ("evilmi-cmake-")))) (autoload (quote evilmi-diff-get-tag) "evil-matchit-diff" "Get tag at point.

(fn)" nil nil) (autoload (quote evilmi-diff-jump) "evil-matchit-diff" "Jump to the matching tag using INFO and NUM.

(fn INFO NUM)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-matchit-diff" (quote ("evilmi-diff-")))) (autoload (quote evilmi-elixir-get-tag) "evil-matchit-elixir" "

(fn)" nil nil) (autoload (quote evilmi-elixir-jump) "evil-matchit-elixir" "

(fn RLT NUM)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-matchit-elixir" (quote ("evilmi-elixir-")))) (autoload (quote evilmi-fortran-get-tag) "evil-matchit-fortran" "

(fn)" nil nil) (autoload (quote evilmi-fortran-jump) "evil-matchit-fortran" "

(fn INFO NUM)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-matchit-fortran" (quote ("evilmi-fortran-")))) (autoload (quote evilmi-html-get-tag) "evil-matchit-html" "Get current tag.

(fn)" nil nil) (autoload (quote evilmi-html-jump) "evil-matchit-html" "Use INFO from current tag to jump NUM times.

(fn INFO NUM)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-matchit-html" (quote ("evilmi-html--")))) (autoload (quote evilmi-javascript-get-tag) "evil-matchit-javascript" "Get tag at point.

(fn)" nil nil) (autoload (quote evilmi-javascript-jump) "evil-matchit-javascript" "Jump to the matching tag using INFO and NUM.

(fn INFO NUM)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-matchit-javascript" (quote ("evilmi-")))) (autoload (quote evilmi-latex-get-tag) "evil-matchit-latex" "

(fn)" nil nil) (autoload (quote evilmi-latex-jump) "evil-matchit-latex" "

(fn RLT NUM)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-matchit-latex" (quote ("evilmi-latex-")))) (autoload (quote evilmi-markdown-get-tag) "evil-matchit-markdown" "Get current tag.  Return (list start-position tag).

(fn)" nil nil) (autoload (quote evilmi-markdown-jump) "evil-matchit-markdown" "Jump to the next tag using INFO and NUM.

(fn INFO NUM)" nil nil) (autoload (quote evilmi-ocaml-get-tag) "evil-matchit-ocaml" "Return information of current tag: (list position-of-word word).

(fn)" nil nil) (autoload (quote evilmi-ocaml-jump) "evil-matchit-ocaml" "

(fn RLT NUM)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-matchit-ocaml" (quote ("evilmi-ocaml-")))) (autoload (quote evilmi-octave-get-tag) "evil-matchit-octave" "Get current tag info.

(fn)" nil nil) (autoload (quote evilmi-octave-jump) "evil-matchit-octave" "Use INFO returned by `evilmi-octave-get-tag' and NUM to jump to matched tag.

(fn INFO NUM)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-matchit-octave" (quote ("evilmi-octave-")))) (autoload (quote evilmi-org-get-tag) "evil-matchit-org" "Get current tag in org file.

(fn)" nil nil) (autoload (quote evilmi-org-jump) "evil-matchit-org" "Jump to the matching tag using INFO and NUM.

(fn INFO NUM)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-matchit-org" (quote ("evilmi-")))) (autoload (quote evilmi-python-get-tag) "evil-matchit-python" "Return '(start-position tag-type keyword).

(fn)" nil nil) (autoload (quote evilmi-python-jump) "evil-matchit-python" "Use INFO returned by `evilmi-python-get-tag' and NUM to jump to matched tag.

(fn INFO NUM)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-matchit-python" (quote ("evilmi--python-")))) (autoload (quote evilmi-ruby-get-tag) "evil-matchit-ruby" "Get tag at point.

(fn)" nil nil) (autoload (quote evilmi-ruby-jump) "evil-matchit-ruby" "Use INFO to jump NUM times.

(fn INFO NUM)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-matchit-ruby" (quote ("evilmi-ruby-")))) (autoload (quote evilmi-script-get-tag) "evil-matchit-script" "Get tag at point.

(fn)" nil nil) (autoload (quote evilmi-script-jump) "evil-matchit-script" "Use INFO returned by `evilmi-script-get-tag' and NUM to jump to matched tag.

(fn INFO NUM)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-matchit-script" (quote ("evilmi-script-")))) (autoload (quote evilmi-sdk-curline) "evil-matchit-sdk" "Get current line text.

(fn)" nil nil) (autoload (quote evilmi-sdk-member) "evil-matchit-sdk" "Check if KEYWORD exist in KEYWORD-LIST.

(fn KEYWORD KEYWORD-LIST)" nil nil) (autoload (quote evilmi-sdk-get-tag-info) "evil-matchit-sdk" "Return (row column is-function-exit-point keyword).
The row and column mark the position in `evilmi-mylang-match-tags'
is-function-exit-point could be unknown status

(fn KEYWORD MATCH-TAGS)" nil nil) (autoload (quote evilmi-sdk-get-tag) "evil-matchit-sdk" "Return '(start-point ((row column is-function-exit-point keyword)).

(fn MATCH-TAGS HOWTOS)" nil nil) (autoload (quote evilmi-sdk-jump) "evil-matchit-sdk" "Use RLT, NUM, MATCH-TAGS and HOWTOS to jump.
Return nil if no matching tag found.  Please note (point) is changed
after calling this function.

(fn RLT NUM MATCH-TAGS HOWTOS)" nil nil) (autoload (quote evilmi-among-fonts-p) "evil-matchit-sdk" "If current font at POS is among FONTS.

(fn POS FONTS)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-matchit-sdk" (quote ("evilmi-")))) (autoload (quote evilmi-sh-get-tag) "evil-matchit-sh" "

(fn)" nil nil) (autoload (quote evilmi-sh-jump) "evil-matchit-sh" "

(fn INFO NUM)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-matchit-sh" (quote ("evilmi-sh-")))) (autoload (quote evilmi-simple-get-tag) "evil-matchit-simple" "Get current tag in simple language.

(fn)" nil nil) (autoload (quote evilmi-simple-jump) "evil-matchit-simple" "Use INFO of current tag to jump to matching tag.  NUM is ignored.

(fn INFO NUM)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-matchit-simple" (quote ("evilmi-")))) (autoload (quote evilmi-sql-get-tag) "evil-matchit-sql" "Get tag at point.

(fn)" nil nil) (autoload (quote evilmi-sql-jump) "evil-matchit-sql" "Use INFO returned by `evilmi-sql-get-tag' and NUM to jump to matched tag.

(fn INFO NUM)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-matchit-sql" (quote ("evilmi-sql-")))) (autoload (quote evilmi-template-get-tag) "evil-matchit-template" "Get tag at point.

(fn)" nil nil) (autoload (quote evilmi-template-jump) "evil-matchit-template" "Jump to the matching tag using INFO and NUM.

(fn INFO NUM)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-matchit-template" (quote ("evilmi-template-")))) (autoload (quote evilmi-prompt-line-p) "evil-matchit-terminal" "If line at POSITION has prompt at the beginning.

(fn &optional POSITION)" nil nil) (autoload (quote evilmi-terminal-get-tag) "evil-matchit-terminal" "Get tag at point.

(fn)" nil nil) (autoload (quote evilmi-terminal-jump) "evil-matchit-terminal" "Use INFO to jump NUM times.

(fn INFO NUM)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-matchit-terminal" (quote ("evilmi-terminal-p")))) (autoload (quote evilmi-verilog-get-tag) "evil-matchit-verilog" "Get tag at point.

(fn)" nil nil) (autoload (quote evilmi-verilog-jump) "evil-matchit-verilog" "Use INFO returned by `evilmi-verlog-get-tag' and NUM to jump to matched tag.

(fn INFO NUM)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-matchit-verilog" (quote ("evilmi-verilog-")))) (provide (quote evil-matchit-autoloads))) "evil-leader" ((evil-leader-autoloads evil-leader) (autoload (quote global-evil-leader-mode) "evil-leader" "Global minor mode for <leader> support.

(fn &optional ARG)" t nil) (autoload (quote evil-leader-mode) "evil-leader" "Minor mode to enable <leader> support.

(fn &optional ARG)" t nil) (autoload (quote evil-leader/set-key) "evil-leader" "Bind `key' to command `def' in `evil-leader/default-map'.

Key has to be readable by `read-kbd-macro' and `def' a command.
Accepts further `key' `def' pairs.

(fn KEY DEF &rest BINDINGS)" t nil) (autoload (quote evil-leader/set-key-for-mode) "evil-leader" "Create keybindings for major-mode `mode' with `key' bound to command `def'.

See `evil-leader/set-key'.

(fn MODE KEY DEF &rest BINDINGS)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-leader" (quote ("evil-leader")))) (provide (quote evil-leader-autoloads))) "evil-easymotion" ((evil-easymotion-autoloads evil-easymotion) (autoload (quote evilem--collect) "evil-easymotion" "Repeatedly execute func, and collect the cursor positions into a list

(fn FUNC &optional SCOPE ALL-WINDOWS INITIAL-POINT SORT-KEY COLLECT-POSTPROCESS INCLUDE-INVISIBLE)" nil nil) (autoload (quote evilem-motion-forward-word-begin) "evil-easymotion" nil t) (autoload (quote evilem-motion-forward-WORD-begin) "evil-easymotion" nil t) (autoload (quote evilem-motion-forward-word-end) "evil-easymotion" nil t) (autoload (quote evilem-motion-forward-WORD-end) "evil-easymotion" nil t) (autoload (quote evilem-motion-backward-word-begin) "evil-easymotion" nil t) (autoload (quote evilem-motion-backward-WORD-begin) "evil-easymotion" nil t) (autoload (quote evilem-motion-backward-word-end) "evil-easymotion" nil t) (autoload (quote evilem-motion-backward-WORD-end) "evil-easymotion" nil t) (autoload (quote evilem-motion-next-line) "evil-easymotion" nil t) (autoload (quote evilem-motion-previous-line) "evil-easymotion" nil t) (autoload (quote evilem-motion-next-visual-line) "evil-easymotion" nil t) (autoload (quote evilem-motion-previous-visual-line) "evil-easymotion" nil t) (autoload (quote evilem-motion-find-char-to) "evil-easymotion" nil t) (autoload (quote evilem-motion-find-char-to-backward) "evil-easymotion" nil t) (autoload (quote evilem-motion-find-char) "evil-easymotion" nil t) (autoload (quote evilem-motion-find-char-backward) "evil-easymotion" nil t) (autoload (quote evilem-motion-backward-section-begin) "evil-easymotion" nil t) (autoload (quote evilem-motion-backward-section-end) "evil-easymotion" nil t) (autoload (quote evilem-motion-forward-section-begin) "evil-easymotion" nil t) (autoload (quote evilem-motion-forward-section-end) "evil-easymotion" nil t) (autoload (quote evilem-motion-backward-sentence-begin) "evil-easymotion" nil t) (autoload (quote evilem-motion-forward-sentence-begin) "evil-easymotion" nil t) (autoload (quote evilem-motion-search-next) "evil-easymotion" nil t) (autoload (quote evilem-motion-search-previous) "evil-easymotion" nil t) (autoload (quote evilem-motion-search-word-forward) "evil-easymotion" nil t) (autoload (quote evilem-motion-search-word-backward) "evil-easymotion" nil t) (autoload (quote evilem-motion-previous-line-first-non-blank) "evil-easymotion" nil t) (autoload (quote evilem-motion-next-line-first-non-blank) "evil-easymotion" nil t) (autoload (quote evilem-default-keybindings) "evil-easymotion" "Define easymotions for all motions evil defines by default

(fn PREFIX)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "evil-easymotion" (quote ("evilem-")))) (provide (quote evil-easymotion-autoloads))) "which-key" ((which-key-autoloads which-key) (defvar which-key-mode nil "Non-nil if Which-Key mode is enabled.
See the `which-key-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `which-key-mode'.") (custom-autoload (quote which-key-mode) "which-key" nil) (autoload (quote which-key-mode) "which-key" "Toggle which-key-mode.

(fn &optional ARG)" t nil) (autoload (quote which-key-setup-side-window-right) "which-key" "Apply suggested settings for side-window that opens on right.

(fn)" t nil) (autoload (quote which-key-setup-side-window-right-bottom) "which-key" "Apply suggested settings for side-window that opens on right
if there is space and the bottom otherwise.

(fn)" t nil) (autoload (quote which-key-setup-side-window-bottom) "which-key" "Apply suggested settings for side-window that opens on bottom.

(fn)" t nil) (autoload (quote which-key-setup-minibuffer) "which-key" "Apply suggested settings for minibuffer.
Do not use this setup if you use the paging commands. Instead use
`which-key-setup-side-window-bottom', which is nearly identical
but more functional.

(fn)" t nil) (autoload (quote which-key-add-keymap-based-replacements) "which-key" "Replace the description of KEY using REPLACEMENT in KEYMAP.
KEY should take a format suitable for use in `kbd'. REPLACEMENT
should be a cons cell of the form (STRING . COMMAND) for each
REPLACEMENT, where STRING is the replacement string and COMMAND
is a symbol corresponding to the intended command to be
replaced. COMMAND can be nil if the binding corresponds to a key
prefix. An example is

(which-key-add-keymap-based-replacements global-map
  \"C-x w\" '(\"Save as\" . write-file)).

For backwards compatibility, REPLACEMENT can also be a string,
but the above format is preferred, and the option to use a string
for REPLACEMENT will eventually be removed.

(fn KEYMAP KEY REPLACEMENT &rest MORE)" nil nil) (autoload (quote which-key-add-key-based-replacements) "which-key" "Replace the description of KEY-SEQUENCE with REPLACEMENT.
KEY-SEQUENCE is a string suitable for use in `kbd'. REPLACEMENT
may either be a string, as in

(which-key-add-key-based-replacements \"C-x 1\" \"maximize\")

a cons of two strings as in

(which-key-add-key-based-replacements \"C-x 8\"
                                        '(\"unicode\" . \"Unicode keys\"))

or a function that takes a (KEY . BINDING) cons and returns a
replacement.

In the second case, the second string is used to provide a longer
name for the keys under a prefix.

MORE allows you to specifcy additional KEY REPLACEMENT pairs.  All
replacements are added to `which-key-replacement-alist'.

(fn KEY-SEQUENCE REPLACEMENT &rest MORE)" nil nil) (autoload (quote which-key-add-major-mode-key-based-replacements) "which-key" "Functions like `which-key-add-key-based-replacements'.
The difference is that MODE specifies the `major-mode' that must
be active for KEY-SEQUENCE and REPLACEMENT (MORE contains
addition KEY-SEQUENCE REPLACEMENT pairs) to apply.

(fn MODE KEY-SEQUENCE REPLACEMENT &rest MORE)" nil nil) (autoload (quote which-key-reload-key-sequence) "which-key" "Simulate entering the key sequence KEY-SEQ.
KEY-SEQ should be a list of events as produced by
`listify-key-sequence'. If nil, KEY-SEQ defaults to
`which-key--current-key-list'. Any prefix arguments that were
used are reapplied to the new key sequence.

(fn &optional KEY-SEQ)" nil nil) (autoload (quote which-key-show-standard-help) "which-key" "Call the command in `which-key--prefix-help-cmd-backup'.
Usually this is `describe-prefix-bindings'.

(fn &optional _)" t nil) (autoload (quote which-key-show-next-page-no-cycle) "which-key" "Show next page of keys unless on the last page, in which case
call `which-key-show-standard-help'.

(fn)" t nil) (autoload (quote which-key-show-previous-page-no-cycle) "which-key" "Show previous page of keys unless on the first page, in which
case do nothing.

(fn)" t nil) (autoload (quote which-key-show-next-page-cycle) "which-key" "Show the next page of keys, cycling from end to beginning
after last page.

(fn &optional _)" t nil) (autoload (quote which-key-show-previous-page-cycle) "which-key" "Show the previous page of keys, cycling from beginning to end
after first page.

(fn &optional _)" t nil) (autoload (quote which-key-show-top-level) "which-key" "Show top-level bindings.

(fn &optional _)" t nil) (autoload (quote which-key-show-major-mode) "which-key" "Show top-level bindings in the map of the current major mode.

This function will also detect evil bindings made using
`evil-define-key' in this map. These bindings will depend on the
current evil state. 

(fn &optional ALL)" t nil) (autoload (quote which-key-show-full-major-mode) "which-key" "Show all bindings in the map of the current major mode.

This function will also detect evil bindings made using
`evil-define-key' in this map. These bindings will depend on the
current evil state. 

(fn)" t nil) (autoload (quote which-key-dump-bindings) "which-key" "Dump bindings from PREFIX into buffer named BUFFER-NAME.

PREFIX should be a string suitable for `kbd'.

(fn PREFIX BUFFER-NAME)" t nil) (autoload (quote which-key-undo-key) "which-key" "Undo last keypress and force which-key update.

(fn &optional _)" t nil) (autoload (quote which-key-C-h-dispatch) "which-key" "Dispatch C-h commands by looking up key in
`which-key-C-h-map'. This command is always accessible (from any
prefix) if `which-key-use-C-h-commands' is non nil.

(fn)" t nil) (autoload (quote which-key-show-keymap) "which-key" "Show the top-level bindings in KEYMAP using which-key.
KEYMAP is selected interactively from all available keymaps.

If NO-PAGING is non-nil, which-key will not intercept subsequent
keypresses for the paging functionality.

(fn KEYMAP &optional NO-PAGING)" t nil) (autoload (quote which-key-show-full-keymap) "which-key" "Show all bindings in KEYMAP using which-key.
KEYMAP is selected interactively from all available keymaps.

(fn KEYMAP)" t nil) (autoload (quote which-key-show-minor-mode-keymap) "which-key" "Show the top-level bindings in KEYMAP using which-key.
KEYMAP is selected interactively by mode in
`minor-mode-map-alist'.

(fn &optional ALL)" t nil) (autoload (quote which-key-show-full-minor-mode-keymap) "which-key" "Show all bindings in KEYMAP using which-key.
KEYMAP is selected interactively by mode in
`minor-mode-map-alist'.

(fn)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "which-key" (quote ("which-key-" "evil-state")))) (provide (quote which-key-autoloads))) "ht" ((ht-autoloads ht) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "ht" (quote nil))) (provide (quote ht-autoloads))) "omni-log" ((omni-log-logger omni-log omni-log-autoloads) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "omni-log" (quote ("omni-log-" "-log")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "omni-log-logger" (quote ("omni-log-")))) (provide (quote omni-log-autoloads))) "omni-quotes" ((omni-quotes-ring omni-quotes-autoloads omni-quotes omni-quotes-reader omni-quotes-timer) (autoload (quote omni-quotes-display-random-quote) "omni-quotes" "Display a random quote obtained from `omni-quotes-random-quote'.
The quote will be prefixed by the current `omni-quotes-prompt'

(fn)" t nil) (defvar omni-quotes-mode nil "Non-nil if Omni-Quotes mode is enabled.
See the `omni-quotes-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `omni-quotes-mode'.") (custom-autoload (quote omni-quotes-mode) "omni-quotes" nil) (autoload (quote omni-quotes-mode) "omni-quotes" "Display random quotes when idle.

(fn &optional ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "omni-quotes" (quote ("omni-quotes-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "omni-quotes-reader" (quote ("omni-quotes-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "omni-quotes-ring" (quote ("omni-quote")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "omni-quotes-timer" (quote ("omni-quotes-idle-")))) (provide (quote omni-quotes-autoloads))) "popwin" ((popwin-autoloads popwin) (autoload (quote popwin:popup-buffer) "popwin" "Show BUFFER in a popup window and return the popup window. If
NOSELECT is non-nil, the popup window will not be selected. If
STICK is non-nil, the popup window will be stuck. If TAIL is
non-nil, the popup window will show the last contents. Calling
`popwin:popup-buffer' during `popwin:popup-buffer' is allowed. In
that case, the buffer of the popup window will be replaced with
BUFFER.

(fn BUFFER &key (WIDTH popwin:popup-window-width) (HEIGHT popwin:popup-window-height) (POSITION popwin:popup-window-position) NOSELECT DEDICATED STICK TAIL)" t nil) (autoload (quote popwin:display-buffer) "popwin" "Display BUFFER-OR-NAME, if possible, in a popup window, or as usual.
This function can be used as a value of
`display-buffer-function'.

(fn BUFFER-OR-NAME &optional NOT-THIS-WINDOW)" t nil) (autoload (quote popwin:pop-to-buffer) "popwin" "Same as `pop-to-buffer' except that this function will use `popwin:display-buffer-1' instead of `display-buffer'.  BUFFER,
OTHER-WINDOW amd NORECORD are the same arguments.

(fn BUFFER &optional OTHER-WINDOW NORECORD)" t nil) (autoload (quote popwin:universal-display) "popwin" "Call the following command interactively with letting `popwin:special-display-config' be `popwin:universal-display-config'.
This will be useful when displaying buffers in popup windows temporarily.

(fn)" t nil) (autoload (quote popwin:one-window) "popwin" "Delete other window than the popup window. C-g restores the original window configuration.

(fn)" t nil) (autoload (quote popwin:popup-buffer-tail) "popwin" "Same as `popwin:popup-buffer' except that the buffer will be `recenter'ed at the bottom.

(fn &rest SAME-AS-POPWIN:POPUP-BUFFER)" t nil) (autoload (quote popwin:find-file) "popwin" "Edit file FILENAME with popup window by `popwin:popup-buffer'.

(fn FILENAME &optional WILDCARDS)" t nil) (autoload (quote popwin:find-file-tail) "popwin" "Edit file FILENAME with popup window by `popwin:popup-buffer-tail'.

(fn FILE &optional WILDCARD)" t nil) (autoload (quote popwin:messages) "popwin" "Display *Messages* buffer in a popup window.

(fn)" t nil) (defvar popwin-mode nil "Non-nil if Popwin mode is enabled.
See the `popwin-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `popwin-mode'.") (custom-autoload (quote popwin-mode) "popwin" nil) (autoload (quote popwin-mode) "popwin" "Minor mode for `popwin-mode'.

(fn &optional ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "popwin" (quote ("popwin:")))) (provide (quote popwin-autoloads))) "map" ((map-autoloads map) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "map" (quote ("map-")))) (provide (quote map-autoloads))) "remind-bindings" ((remind-bindings-autoloads remind-bindings) (autoload (quote remind-bindings-initialise) "remind-bindings" "Collect all \342\200\230use-package\342\200\231 and global key bindings and set the omni-quotes list.

(fn)" nil nil) (autoload (quote remind-bindings-togglebuffer) "remind-bindings" "Toggle the sidebar with static window rules.  Initialise and recurse to a max LEVEL of 2.

(fn &optional LEVEL)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "remind-bindings" (quote ("remind-bindings-")))) (provide (quote remind-bindings-autoloads))) "company" ((company-ispell company-dabbrev company-keywords company-yasnippet company-bbdb company-elisp company-template company-autoloads company-cmake company-capf company-clang company-css company-nxml company-abbrev company-gtags company-etags company-tempo company-oddmuse company-tng company company-files company-semantic company-dabbrev-code) (autoload (quote company-mode) "company" "\"complete anything\"; is an in-buffer completion framework.
Completion starts automatically, depending on the values
`company-idle-delay' and `company-minimum-prefix-length'.

Completion can be controlled with the commands:
`company-complete-common', `company-complete-selection', `company-complete',
`company-select-next', `company-select-previous'.  If these commands are
called before `company-idle-delay', completion will also start.

Completions can be searched with `company-search-candidates' or
`company-filter-candidates'.  These can be used while completion is
inactive, as well.

The completion data is retrieved using `company-backends' and displayed
using `company-frontends'.  If you want to start a specific backend, call
it interactively or use `company-begin-backend'.

By default, the completions list is sorted alphabetically, unless the
backend chooses otherwise, or `company-transformers' changes it later.

regular keymap (`company-mode-map'):

\\{company-mode-map}
keymap during active completions (`company-active-map'):

\\{company-active-map}

(fn &optional ARG)" t nil) (defvar global-company-mode nil "Non-nil if Global Company mode is enabled.
See the `global-company-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-company-mode'.") (custom-autoload (quote global-company-mode) "company" nil) (autoload (quote global-company-mode) "company" "Toggle Company mode in all buffers.
With prefix ARG, enable Global Company mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Company mode is enabled in all buffers where
`company-mode-on' would do it.
See `company-mode' for more information on Company mode.

(fn &optional ARG)" t nil) (autoload (quote company-manual-begin) "company" "

(fn)" t nil) (autoload (quote company-complete) "company" "Insert the common part of all candidates or the current selection.
The first time this is called, the common part is inserted, the second
time, or when the selection has been changed, the selected candidate is
inserted.

(fn)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company" (quote ("company-")))) (autoload (quote company-abbrev) "company-abbrev" "`company-mode' completion backend for abbrev.

(fn COMMAND &optional ARG &rest IGNORED)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company-abbrev" (quote ("company-abbrev-insert")))) (autoload (quote company-bbdb) "company-bbdb" "`company-mode' completion backend for BBDB.

(fn COMMAND &optional ARG &rest IGNORE)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company-bbdb" (quote ("company-bbdb-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company-capf" (quote ("company-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company-clang" (quote ("company-clang")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company-cmake" (quote ("company-cmake")))) (autoload (quote company-css) "company-css" "`company-mode' completion backend for `css-mode'.

(fn COMMAND &optional ARG &rest IGNORED)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company-css" (quote ("company-css-")))) (autoload (quote company-dabbrev) "company-dabbrev" "dabbrev-like `company-mode' completion backend.

(fn COMMAND &optional ARG &rest IGNORED)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company-dabbrev" (quote ("company-dabbrev-")))) (autoload (quote company-dabbrev-code) "company-dabbrev-code" "dabbrev-like `company-mode' backend for code.
The backend looks for all symbols in the current buffer that aren't in
comments or strings.

(fn COMMAND &optional ARG &rest IGNORED)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company-dabbrev-code" (quote ("company-dabbrev-code-")))) (autoload (quote company-elisp) "company-elisp" "`company-mode' completion backend for Emacs Lisp.

(fn COMMAND &optional ARG &rest IGNORED)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company-elisp" (quote ("company-elisp-")))) (autoload (quote company-etags) "company-etags" "`company-mode' completion backend for etags.

(fn COMMAND &optional ARG &rest IGNORED)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company-etags" (quote ("company-etags-")))) (autoload (quote company-files) "company-files" "`company-mode' completion backend existing file names.
Completions works for proper absolute and relative files paths.
File paths with spaces are only supported inside strings.

(fn COMMAND &optional ARG &rest IGNORED)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company-files" (quote ("company-file")))) (autoload (quote company-gtags) "company-gtags" "`company-mode' completion backend for GNU Global.

(fn COMMAND &optional ARG &rest IGNORED)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company-gtags" (quote ("company-gtags-")))) (autoload (quote company-ispell) "company-ispell" "`company-mode' completion backend using Ispell.

(fn COMMAND &optional ARG &rest IGNORED)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company-ispell" (quote ("company-ispell-")))) (autoload (quote company-keywords) "company-keywords" "`company-mode' backend for programming language keywords.

(fn COMMAND &optional ARG &rest IGNORED)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company-keywords" (quote ("company-keywords-")))) (autoload (quote company-nxml) "company-nxml" "`company-mode' completion backend for `nxml-mode'.

(fn COMMAND &optional ARG &rest IGNORED)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company-nxml" (quote ("company-nxml-")))) (autoload (quote company-oddmuse) "company-oddmuse" "`company-mode' completion backend for `oddmuse-mode'.

(fn COMMAND &optional ARG &rest IGNORED)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company-oddmuse" (quote ("company-oddmuse-")))) (autoload (quote company-semantic) "company-semantic" "`company-mode' completion backend using CEDET Semantic.

(fn COMMAND &optional ARG &rest IGNORED)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company-semantic" (quote ("company-semantic-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company-template" (quote ("company-template-")))) (autoload (quote company-tempo) "company-tempo" "`company-mode' completion backend for tempo.

(fn COMMAND &optional ARG &rest IGNORED)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company-tempo" (quote ("company-tempo-")))) (autoload (quote company-tng-frontend) "company-tng" "When the user changes the selection at least once, this
frontend will display the candidate in the buffer as if it's
already there and any key outside of `company-active-map' will
confirm the selection and finish the completion.

(fn COMMAND)" nil nil) (define-obsolete-function-alias (quote company-tng-configure-default) (quote company-tng-mode) "0.9.14" "Applies the default configuration to enable company-tng.") (defvar company-tng-mode nil "Non-nil if Company-Tng mode is enabled.
See the `company-tng-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `company-tng-mode'.") (custom-autoload (quote company-tng-mode) "company-tng" nil) (autoload (quote company-tng-mode) "company-tng" "This minor mode enables `company-tng-frontend'.

(fn &optional ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company-tng" (quote ("company-tng-")))) (autoload (quote company-yasnippet) "company-yasnippet" "`company-mode' backend for `yasnippet'.

This backend should be used with care, because as long as there are
snippets defined for the current major mode, this backend will always
shadow backends that come after it.  Recommended usages:

* In a buffer-local value of `company-backends', grouped with a backend or
  several that provide actual text completions.

  (add-hook \\='js-mode-hook
            (lambda ()
              (set (make-local-variable \\='company-backends)
                   \\='((company-dabbrev-code company-yasnippet)))))

* After keyword `:with', grouped with other backends.

  (push \\='(company-semantic :with company-yasnippet) company-backends)

* Not in `company-backends', just bound to a key.

  (global-set-key (kbd \"C-c y\") \\='company-yasnippet)

(fn COMMAND &optional ARG &rest IGNORE)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company-yasnippet" (quote ("company-yasnippet-")))) (provide (quote company-autoloads))) "memoize" ((memoize memoize-autoloads) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "memoize" (quote ("defmemoize" "memoize")))) (provide (quote memoize-autoloads))) "ido-completing-read+" ((ido-completing-read+ ido-completing-read+-autoloads) (defvar ido-cr+-minibuffer-depth -1 "Minibuffer depth of the most recent ido-cr+ activation.

If this equals the current minibuffer depth, then the minibuffer
is currently being used by ido-cr+, and ido-cr+ features will be
active. Otherwise, something else is using the minibuffer and
ido-cr+ features will be deactivated to avoid interfering with
the other command.

This is set to -1 by default, since `(minibuffer-depth)' should
never return this value.") (defvar ido-cr+-replace-completely nil "If non-nil, replace `ido-completeing-read' completely with ido-cr+.

Enabling this may interfere with or cause errors in other
packages that use `ido-completing-read'. If you discover any such
incompatibilities, please file a bug report at
https://github.com/DarwinAwardWinner/ido-completing-read-plus/issues") (custom-autoload (quote ido-cr+-replace-completely) "ido-completing-read+" t) (defsubst ido-cr+-active nil "Return non-nil if ido-cr+ is currently using the minibuffer." (>= ido-cr+-minibuffer-depth (minibuffer-depth))) (autoload (quote ido-completing-read+) "ido-completing-read+" "Ido-based method for reading from the minibuffer with completion.

See `completing-read' for the meaning of the arguments.

This function is a wrapper for `ido-completing-read' designed to
be used as the value of `completing-read-function'. Importantly,
it detects edge cases that ido cannot handle and uses normal
completion for them.

See `completing-read' for the meaning of the arguments.

(fn PROMPT COLLECTION &optional PREDICATE REQUIRE-MATCH INITIAL-INPUT HIST DEF INHERIT-INPUT-METHOD)" nil nil) (autoload (quote ido-completing-read@ido-cr+-replace) "ido-completing-read+" "This advice allows ido-cr+ to completely replace `ido-completing-read'.

See the varaible `ido-cr+-replace-completely' for more information.

(fn ORIG-FUN &rest ARGS)" nil nil) (advice-add (quote ido-completing-read) :around (function ido-completing-read@ido-cr+-replace)) (autoload (quote call-interactively@ido-cr+-record-current-command) "ido-completing-read+" "Let-bind the command being interactively called.

See `ido-cr+-current-command' for more information.

(fn ORIG-FUN COMMAND &rest ARGS)" nil nil) (advice-add (quote call-interactively) :around (function call-interactively@ido-cr+-record-current-command)) (defvar ido-ubiquitous-mode nil "Non-nil if Ido-Ubiquitous mode is enabled.
See the `ido-ubiquitous-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `ido-ubiquitous-mode'.") (custom-autoload (quote ido-ubiquitous-mode) "ido-completing-read+" nil) (autoload (quote ido-ubiquitous-mode) "ido-completing-read+" "Use ido completion instead of standard completion almost everywhere.

If this mode causes problems for a function, you can customize
when ido completion is or is not used by customizing
`ido-cr+-disable-list'.

(fn &optional ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "ido-completing-read+" (quote ("ido-" "minibuf-eldef-update-minibuffer@ido-cr+-compat")))) (provide (quote ido-completing-read+-autoloads))) "spinner" ((spinner-autoloads spinner) (autoload (quote spinner-create) "spinner" "Create a spinner of the given TYPE.
The possible TYPEs are described in `spinner--type-to-frames'.

FPS, if given, is the number of desired frames per second.
Default is `spinner-frames-per-second'.

If BUFFER-LOCAL is non-nil, the spinner will be automatically
deactivated if the buffer is killed.  If BUFFER-LOCAL is a
buffer, use that instead of current buffer.

When started, in order to function properly, the spinner runs a
timer which periodically calls `force-mode-line-update' in the
current buffer.  If BUFFER-LOCAL was set at creation time, then
`force-mode-line-update' is called in that buffer instead.  When
the spinner is stopped, the timer is deactivated.

DELAY, if given, is the number of seconds to wait after starting
the spinner before actually displaying it. It is safe to cancel
the spinner before this time, in which case it won't display at
all.

(fn &optional TYPE BUFFER-LOCAL FPS DELAY)" nil nil) (autoload (quote spinner-start) "spinner" "Start a mode-line spinner of given TYPE-OR-OBJECT.
If TYPE-OR-OBJECT is an object created with `make-spinner',
simply activate it.  This method is designed for minor modes, so
they can use the spinner as part of their lighter by doing:
    '(:eval (spinner-print THE-SPINNER))
To stop this spinner, call `spinner-stop' on it.

If TYPE-OR-OBJECT is anything else, a buffer-local spinner is
created with this type, and it is displayed in the
`mode-line-process' of the buffer it was created it.  Both
TYPE-OR-OBJECT and FPS are passed to `make-spinner' (which see).
To stop this spinner, call `spinner-stop' in the same buffer.

Either way, the return value is a function which can be called
anywhere to stop this spinner.  You can also call `spinner-stop'
in the same buffer where the spinner was created.

FPS, if given, is the number of desired frames per second.
Default is `spinner-frames-per-second'.

DELAY, if given, is the number of seconds to wait until actually
displaying the spinner. It is safe to cancel the spinner before
this time, in which case it won't display at all.

(fn &optional TYPE-OR-OBJECT FPS DELAY)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "spinner" (quote ("spinner-")))) (provide (quote spinner-autoloads))) "markdown-mode" ((markdown-mode-autoloads markdown-mode) (autoload (quote markdown-mode) "markdown-mode" "Major mode for editing Markdown files.

(fn)" t nil) (add-to-list (quote auto-mode-alist) (quote ("\\.\\(?:md\\|markdown\\|mkd\\|mdown\\|mkdn\\|mdwn\\)\\'" . markdown-mode))) (autoload (quote gfm-mode) "markdown-mode" "Major mode for editing GitHub Flavored Markdown files.

(fn)" t nil) (autoload (quote markdown-view-mode) "markdown-mode" "Major mode for viewing Markdown content.

(fn)" t nil) (autoload (quote gfm-view-mode) "markdown-mode" "Major mode for viewing GitHub Flavored Markdown content.

(fn)" t nil) (autoload (quote markdown-live-preview-mode) "markdown-mode" "Toggle native previewing on save for a specific markdown file.

(fn &optional ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "markdown-mode" (quote ("gfm-" "markdown" "defun-markdown-")))) (provide (quote markdown-mode-autoloads))) "lv" ((lv lv-autoloads) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lv" (quote ("lv-")))) (provide (quote lv-autoloads))) "lsp-mode" ((lsp-pylsp lsp-tex lsp lsp-vala lsp-beancount lsp-semantic-tokens lsp-pyls lsp-vhdl lsp-terraform lsp-d lsp-vimscript lsp-cmake lsp-prolog lsp-rf lsp-actionscript lsp-elm lsp-xml lsp-bash lsp-completion lsp-protocol lsp-yaml lsp-sqls lsp-ido lsp-ocaml lsp-v lsp-solargraph lsp-perl lsp-dockerfile lsp-svelte lsp-erlang lsp-angular lsp-json lsp-clojure lsp-vetur lsp-fsharp lsp-mode-autoloads lsp-eslint lsp-fortran lsp-verilog lsp-clangd lsp-crystal lsp-gdscript lsp-pwsh lsp-rust lsp-racket lsp-steep lsp-nim lsp-elixir lsp-graphql lsp-modeline lsp-javascript lsp-haxe lsp-lens lsp-mode lsp-css lsp-sorbet lsp-icons lsp-iedit lsp-kotlin lsp-html lsp-headerline lsp-purescript lsp-dhall lsp-groovy lsp-dired lsp-lua lsp-zig lsp-diagnostics lsp-php lsp-markdown lsp-csharp lsp-ada lsp-nix lsp-r lsp-hack lsp-go) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-actionscript" (quote ("lsp-actionscript-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-ada" (quote ("lsp-ada-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-angular" (quote ("lsp-client")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-bash" (quote ("lsp-bash-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-beancount" (quote ("lsp-beancount-")))) (autoload (quote lsp-cpp-flycheck-clang-tidy-error-explainer) "lsp-clangd" "Explain a clang-tidy ERROR by scraping documentation from llvm.org.

(fn ERROR)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-clangd" (quote ("lsp-c")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-clojure" (quote ("lsp-clojure-")))) (define-obsolete-variable-alias (quote lsp-prefer-capf) (quote lsp-completion-provider) "lsp-mode 7.0.1") (define-obsolete-variable-alias (quote lsp-enable-completion-at-point) (quote lsp-completion-enable) "lsp-mode 7.0.1") (autoload (quote lsp-completion-at-point) "lsp-completion" "Get lsp completions.

(fn)" nil nil) (autoload (quote lsp-completion--enable) "lsp-completion" "Enable LSP completion support.

(fn)" nil nil) (autoload (quote lsp-completion-mode) "lsp-completion" "Toggle LSP completion support.

(fn &optional ARG)" t nil) (add-hook (quote lsp-configure-hook) (lambda nil (when (and lsp-auto-configure lsp-completion-enable) (lsp-completion--enable)))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-completion" (quote ("lsp-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-crystal" (quote ("lsp-clients-crystal-executable")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-csharp" (quote ("lsp-csharp-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-css" (quote ("lsp-css-")))) (define-obsolete-variable-alias (quote lsp-diagnostic-package) (quote lsp-diagnostics-provider) "lsp-mode 7.0.1") (define-obsolete-variable-alias (quote lsp-flycheck-default-level) (quote lsp-diagnostics-flycheck-default-level) "lsp-mode 7.0.1") (autoload (quote lsp-diagnostics-lsp-checker-if-needed) "lsp-diagnostics" "

(fn)" nil nil) (autoload (quote lsp-diagnostics--enable) "lsp-diagnostics" "Enable LSP checker support.

(fn)" nil nil) (autoload (quote lsp-diagnostics-mode) "lsp-diagnostics" "Toggle LSP diagnostics integration.

(fn &optional ARG)" t nil) (add-hook (quote lsp-configure-hook) (lambda nil (when lsp-auto-configure (lsp-diagnostics--enable)))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-diagnostics" (quote ("lsp-diagnostics-")))) (defvar lsp-dired-mode nil "Non-nil if Lsp-Dired mode is enabled.
See the `lsp-dired-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `lsp-dired-mode'.") (custom-autoload (quote lsp-dired-mode) "lsp-dired" nil) (autoload (quote lsp-dired-mode) "lsp-dired" "Display `lsp-mode' icons for each file in a dired buffer.

(fn &optional ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-dired" (quote ("lsp-dired-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-dockerfile" (quote ("lsp-dockerfile-language-server-command")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-elixir" (quote ("lsp-elixir-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-elm" (quote ("lsp-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-erlang" (quote ("lsp-erlang-server-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-eslint" (quote ("lsp-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-fortran" (quote ("lsp-clients-")))) (autoload (quote lsp-fsharp--workspace-load) "lsp-fsharp" "Load all of the provided PROJECTS.

(fn PROJECTS)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-fsharp" (quote ("lsp-fsharp-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-gdscript" (quote ("lsp-gdscript-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-go" (quote ("lsp-go-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-graphql" (quote ("lsp-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-groovy" (quote ("lsp-groovy-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-hack" (quote ("lsp-clients-hack-command")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-haxe" (quote ("lsp-")))) (autoload (quote lsp-headerline-breadcrumb-mode) "lsp-headerline" "Toggle breadcrumb on headerline.

(fn &optional ARG)" t nil) (autoload (quote lsp-breadcrumb-go-to-symbol) "lsp-headerline" "Go to the symbol on breadcrumb at SYMBOL-POSITION.

(fn SYMBOL-POSITION)" t nil) (autoload (quote lsp-breadcrumb-narrow-to-symbol) "lsp-headerline" "Narrow to the symbol range on breadcrumb at SYMBOL-POSITION.

(fn SYMBOL-POSITION)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-headerline" (quote ("lsp-headerline-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-html" (quote ("lsp-html-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-icons" (quote ("lsp-")))) (autoload (quote lsp-ido-workspace-symbol) "lsp-ido" "`ido' for lsp workspace/symbol.
When called with prefix ARG the default selection will be symbol at point.

(fn ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-ido" (quote ("lsp-ido-")))) (autoload (quote lsp-iedit-highlights) "lsp-iedit" "Start an `iedit' operation on the documentHighlights at point.
This can be used as a primitive `lsp-rename' replacement if the
language server doesn't support renaming.

See also `lsp-enable-symbol-highlighting'.

(fn)" t nil) (autoload (quote lsp-iedit-linked-ranges) "lsp-iedit" "Start an `iedit' for `textDocument/linkedEditingRange'

(fn)" t nil) (autoload (quote lsp-evil-multiedit-highlights) "lsp-iedit" "Start an `evil-multiedit' operation on the documentHighlights at point.
This can be used as a primitive `lsp-rename' replacement if the
language server doesn't support renaming.

See also `lsp-enable-symbol-highlighting'.

(fn)" t nil) (autoload (quote lsp-evil-multiedit-linked-ranges) "lsp-iedit" "Start an `evil-multiedit' for `textDocument/linkedEditingRange'

(fn)" t nil) (autoload (quote lsp-evil-state-highlights) "lsp-iedit" "Start `iedit-mode'. for `textDocument/documentHighlight'

(fn)" t nil) (autoload (quote lsp-evil-state-linked-ranges) "lsp-iedit" "Start `iedit-mode'. for `textDocument/linkedEditingRange'

(fn)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-iedit" (quote ("lsp-iedit--on-ranges")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-javascript" (quote ("lsp-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-json" (quote ("lsp-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-kotlin" (quote ("lsp-")))) (autoload (quote lsp-lens--enable) "lsp-lens" "Enable lens mode.

(fn)" nil nil) (autoload (quote lsp-lens-show) "lsp-lens" "Display lenses in the buffer.

(fn)" t nil) (autoload (quote lsp-lens-hide) "lsp-lens" "Delete all lenses.

(fn)" t nil) (autoload (quote lsp-lens-mode) "lsp-lens" "Toggle code-lens overlays.

(fn &optional ARG)" t nil) (autoload (quote lsp-avy-lens) "lsp-lens" "Click lsp lens using `avy' package.

(fn)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-lens" (quote ("lsp-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-lua" (quote ("lsp-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-markdown" (quote ("lsp-markdown-")))) (put (quote lsp-enable-file-watchers) (quote safe-local-variable) (function booleanp)) (put (quote lsp-file-watch-threshold) (quote safe-local-variable) (lambda (i) (or (numberp i) (not i)))) (autoload (quote lsp-load-vscode-workspace) "lsp-mode" "Load vscode workspace from FILE

(fn FILE)" t nil) (autoload (quote lsp-save-vscode-workspace) "lsp-mode" "Save vscode workspace to FILE

(fn FILE)" t nil) (autoload (quote lsp-install-server) "lsp-mode" "Interactively install or re-install server.
When prefix UPDATE? is t force installation even if the server is present.

(fn UPDATE\\=\\? &optional SERVER-ID)" t nil) (autoload (quote lsp-update-server) "lsp-mode" "Interactively update a server.

(fn &optional SERVER-ID)" t nil) (autoload (quote lsp-ensure-server) "lsp-mode" "Ensure server SERVER-ID

(fn SERVER-ID)" nil nil) (autoload (quote lsp) "lsp-mode" "Entry point for the server startup.
When ARG is t the lsp mode will start new language server even if
there is language server which can handle current language. When
ARG is nil current file will be opened in multi folder language
server if there is such. When `lsp' is called with prefix
argument ask the user to select which language server to start.

(fn &optional ARG)" t nil) (autoload (quote lsp-deferred) "lsp-mode" "Entry point that defers server startup until buffer is visible.
`lsp-deferred' will wait until the buffer is visible before invoking `lsp'.
This avoids overloading the server with many files when starting Emacs.

(fn)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-mode" (quote ("lsp-" "defcustom-lsp" "make-lsp-client" "with-lsp-workspace" "when-lsp-workspace")))) (define-obsolete-variable-alias (quote lsp-diagnostics-modeline-scope) (quote lsp-modeline-diagnostics-scope) "lsp-mode 7.0.1") (autoload (quote lsp-modeline-code-actions-mode) "lsp-modeline" "Toggle code actions on modeline.

(fn &optional ARG)" t nil) (define-obsolete-function-alias (quote lsp-diagnostics-modeline-mode) (quote lsp-modeline-diagnostics-mode) "lsp-mode 7.0.1") (autoload (quote lsp-modeline-diagnostics-mode) "lsp-modeline" "Toggle diagnostics modeline.

(fn &optional ARG)" t nil) (autoload (quote lsp-modeline-workspace-status-mode) "lsp-modeline" "Toggle workspace status on modeline.

(fn &optional ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-modeline" (quote ("lsp-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-nix" (quote ("lsp-nix-server-path")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-ocaml" (quote ("lsp-ocaml-l")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-perl" (quote ("lsp-perl-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-php" (quote ("lsp-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-prolog" (quote ("lsp-prolog-server-command")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-protocol" (quote ("lsp" "dash-expand:&RangeToPoint")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-purescript" (quote ("lsp-purescript-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-pwsh" (quote ("lsp-pwsh-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-pyls" (quote ("lsp-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-pylsp" (quote ("lsp-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-r" (quote ("lsp-clients-r-server-command")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-racket" (quote ("lsp-racket-lang")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-rf" (quote ("parse-rf-language-server-" "expand-start-command" "lsp-rf-language-server-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-rust" (quote ("lsp-")))) (autoload (quote lsp--semantic-tokens-initialize-buffer) "lsp-semantic-tokens" "Initialize the buffer for semantic tokens.
IS-RANGE-PROVIDER is non-nil when server supports range requests.

(fn)" nil nil) (autoload (quote lsp--semantic-tokens-initialize-workspace) "lsp-semantic-tokens" "Initialize semantic tokens for WORKSPACE.

(fn WORKSPACE)" nil nil) (autoload (quote lsp-semantic-tokens--warn-about-deprecated-setting) "lsp-semantic-tokens" "Warn about deprecated semantic highlighting variable.

(fn)" nil nil) (autoload (quote lsp-semantic-tokens--enable) "lsp-semantic-tokens" "Enable semantic tokens mode.

(fn)" nil nil) (autoload (quote lsp-semantic-tokens-mode) "lsp-semantic-tokens" "Toggle semantic-tokens support.

(fn &optional ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-semantic-tokens" (quote ("lsp-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-solargraph" (quote ("lsp-solargraph-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-sorbet" (quote ("lsp-sorbet-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-sqls" (quote ("lsp-sql")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-steep" (quote ("lsp-steep-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-svelte" (quote ("lsp-svelte-plugin-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-terraform" (quote ("lsp-terraform-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-tex" (quote ("lsp-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-v" (quote ("lsp-v-vls-executable")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-vala" (quote ("lsp-clients-vala-ls-executable")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-verilog" (quote ("lsp-clients-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-vetur" (quote ("lsp-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-vhdl" (quote ("lsp-vhdl-" "ghdl-ls-bin-name" "vhdl-" "hdl-checker-bin-name")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-vimscript" (quote ("lsp-clients-vim-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-xml" (quote ("lsp-xml-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-yaml" (quote ("lsp-yaml-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-zig" (quote ("lsp-zig-zls-executable")))) (provide (quote lsp-mode-autoloads))) "lsp-ui" ((lsp-ui-sideline lsp-ui-util lsp-ui lsp-ui-peek lsp-ui-doc lsp-ui-imenu lsp-ui-autoloads lsp-ui-flycheck) (autoload (quote lsp-ui-mode) "lsp-ui" "Toggle language server UI mode on or off.
\342\200\230lsp-ui-mode\342\200\231 is a minor mode that contains a series of useful UI
integrations for \342\200\230lsp-mode\342\200\231.  With a prefix argument ARG, enable
language server UI mode if ARG is positive, and disable it
otherwise.  If called from Lisp, enable the mode if ARG is
omitted or nil, and toggle it if ARG is \342\200\230toggle\342\200\231.

(fn &optional ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-ui" (quote ("lsp-ui-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-ui-doc" (quote ("lsp-ui-doc-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-ui-flycheck" (quote ("lsp-ui-flycheck-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-ui-imenu" (quote ("lsp-ui-imenu")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-ui-peek" (quote ("lsp-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-ui-sideline" (quote ("lsp-ui-sideline")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-ui-util" (quote ("lsp-ui-util-")))) (provide (quote lsp-ui-autoloads))) "esup" ((esup-child esup esup-autoloads) (autoload (quote esup) "esup" "Profile the startup time of Emacs in the background.
If INIT-FILE is non-nil, profile that instead of USER-INIT-FILE.
ARGS is a list of extra command line arguments to pass to Emacs.

(fn &optional INIT-FILE &rest ARGS)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "esup" (quote ("esup-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "esup-child" (quote ("esup-" "with-esup-child-increasing-depth")))) (provide (quote esup-autoloads))) "pfuture" ((pfuture-autoloads pfuture) (autoload (quote pfuture-new) "pfuture" "Create a new future process for command CMD.
Any arguments after the command are interpreted as arguments to the command.
This will return a process object with additional 'stderr and 'stdout
properties, which can be read via (process-get process 'stdout) and
(process-get process 'stderr) or alternatively with
(pfuture-result process) or (pfuture-stderr process).

Note that CMD must be a *sequence* of strings, meaning
this is wrong: (pfuture-new \"git status\")
this is right: (pfuture-new \"git\" \"status\")

(fn &rest CMD)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "pfuture" (quote ("pfuture-")))) (provide (quote pfuture-autoloads))) "hydra" ((hydra-ox hydra-autoloads hydra hydra-examples) (autoload (quote defhydra) "hydra" "Create a Hydra - a family of functions with prefix NAME.

NAME should be a symbol, it will be the prefix of all functions
defined here.

BODY has the format:

    (BODY-MAP BODY-KEY &rest BODY-PLIST)

DOCSTRING will be displayed in the echo area to identify the
Hydra.  When DOCSTRING starts with a newline, special Ruby-style
substitution will be performed by `hydra--format'.

Functions are created on basis of HEADS, each of which has the
format:

    (KEY CMD &optional HINT &rest PLIST)

BODY-MAP is a keymap; `global-map' is used quite often.  Each
function generated from HEADS will be bound in BODY-MAP to
BODY-KEY + KEY (both are strings passed to `kbd'), and will set
the transient map so that all following heads can be called
though KEY only.  BODY-KEY can be an empty string.

CMD is a callable expression: either an interactive function
name, or an interactive lambda, or a single sexp (it will be
wrapped in an interactive lambda).

HINT is a short string that identifies its head.  It will be
printed beside KEY in the echo erea if `hydra-is-helpful' is not
nil.  If you don't even want the KEY to be printed, set HINT
explicitly to nil.

The heads inherit their PLIST from BODY-PLIST and are allowed to
override some keys.  The keys recognized are :exit, :bind, and :column.
:exit can be:

- nil (default): this head will continue the Hydra state.
- t: this head will stop the Hydra state.

:bind can be:
- nil: this head will not be bound in BODY-MAP.
- a lambda taking KEY and CMD used to bind a head.

:column is a string that sets the column for all subsequent heads.

It is possible to omit both BODY-MAP and BODY-KEY if you don't
want to bind anything.  In that case, typically you will bind the
generated NAME/body command.  This command is also the return
result of `defhydra'.

(fn NAME BODY &optional DOCSTRING &rest HEADS)" nil t) (function-put (quote defhydra) (quote lisp-indent-function) (quote defun)) (function-put (quote defhydra) (quote doc-string-elt) (quote 3)) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "hydra" (quote ("hydra-" "defhydra")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "hydra-examples" (quote ("hydra-" "org-agenda-cts" "whitespace-mode")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "hydra-ox" (quote ("hydra-ox")))) (provide (quote hydra-autoloads))) "posframe" ((posframe-benchmark posframe-autoloads posframe) (autoload (quote posframe-workable-p) "posframe" "Test posframe workable status.

(fn)" nil nil) (autoload (quote posframe-show) "posframe" "Pop up a posframe to show STRING at POSITION.

 (1) POSITION

POSITION can be:
1. An integer, meaning point position.
2. A cons of two integers, meaning absolute X and Y coordinates.
3. Other type, in which case the corresponding POSHANDLER should be
   provided.

 (2) POSHANDLER

POSHANDLER is a function of one argument returning an actual
position.  Its argument is a plist of the following form:

  (:position xxx
   :poshandler xxx
   :font-height xxx
   :font-width xxx
   :posframe xxx
   :posframe-width xxx
   :posframe-height xxx
   :posframe-buffer xxx
   :parent-frame xxx
   :parent-window-left xxx
   :parent-window-top xxx
   :parent-frame-width xxx
   :parent-frame-height xxx
   :parent-window xxx
   :parent-window-width  xxx
   :parent-window-height xxx
   :mouse-x xxx
   ;mouse-y xxx
   :minibuffer-height xxx
   :mode-line-height  xxx
   :header-line-height xxx
   :tab-line-height xxx
   :x-pixel-offset xxx
   :y-pixel-offset xxx)

By default, poshandler is auto-selected based on the type of POSITION,
but the selection can be overridden using the POSHANDLER argument.

The names of poshandler functions are like:

   `posframe-poshandler-p0.5p0-to-w0.5p1'

which mean align posframe(0.5, 0) to a position(a, b)

1. a = x of window(0.5, 0)
2. b = y of point(1, 1)

    posframe(p), frame(f), window(w), point(p), mouse(m)

         (0,0)      (0.5,0)      (1,0)
          +------------+-----------+
          |                        |
          |                        |
          |                        |
 (0, 0.5) +                        + (1, 0.5)
          |                        |
          |                        |
          |                        |
          +------------+-----------+
         (0,1)      (0.5,1)      (1,1)

The alias of builtin poshandler functions are listed below:

1.  `posframe-poshandler-frame-center'
2.  `posframe-poshandler-frame-top-center'
3.  `posframe-poshandler-frame-top-left-corner'
4.  `posframe-poshandler-frame-top-right-corner'
5.  `posframe-poshandler-frame-bottom-center'
6.  `posframe-poshandler-frame-bottom-left-corner'
7.  `posframe-poshandler-frame-bottom-right-corner'
8.  `posframe-poshandler-window-center'
9.  `posframe-poshandler-window-top-center'
10. `posframe-poshandler-window-top-left-corner'
11. `posframe-poshandler-window-top-right-corner'
12. `posframe-poshandler-window-bottom-center'
13. `posframe-poshandler-window-bottom-left-corner'
14. `posframe-poshandler-window-bottom-right-corner'
15. `posframe-poshandler-point-top-left-corner'
16. `posframe-poshandler-point-bottom-left-corner'
17. `posframe-poshandler-point-bottom-left-corner-upward'
18. `posframe-poshandler-point-window-center'

by the way, poshandler can be used by other packages easily with
the help of function `posframe-poshandler-argbuilder'.  like:

   (let* ((info (posframe-poshandler-argbuilder *MY-CHILD-FRAME*))
          (posn (posframe-poshandler-window-center
                 `(:posframe-width 800 :posframe-height 400 ,@info))))
     `((left . ,(car posn))
       (top . ,(cdr posn))))

 (3) POSHANDLER-EXTRA-INFO

POSHANDLER-EXTRA-INFO is a plist, which will prepend to the
argument of poshandler function: 'info', it will *OVERRIDE* the
exist key in 'info'.

 (4) BUFFER-OR-NAME

This posframe's buffer is BUFFER-OR-NAME, which can be a buffer
or a name of a (possibly nonexistent) buffer.

buffer name can prefix with space, for example ' *mybuffer*', so
the buffer name will hide for ibuffer and `list-buffers'.

 (5) NO-PROPERTIES

If NO-PROPERTIES is non-nil, The STRING's properties will
be removed before being shown in posframe.

 (6) HEIGHT, MAX-HEIGHT, MIN-HEIGHT, WIDTH, MAX-WIDTH and MIN-WIDTH

These arguments are specified in the canonical character width
and height of posframe, more details can be found in docstring of
function `fit-frame-to-buffer',

 (7) LEFT-FRINGE and RIGHT-FRINGE

If LEFT-FRINGE or RIGHT-FRINGE is a number, left fringe or
right fringe with be shown with the specified width.

 (8) BORDER-WIDTH, BORDER-COLOR, INTERNAL-BORDER-WIDTH and INTERNAL-BORDER-COLOR

By default, posframe shows no borders, but users can specify
borders by setting BORDER-WIDTH to a positive number.  Border
color can be specified by BORDER-COLOR.

INTERNAL-BORDER-WIDTH and INTERNAL-BORDER-COLOR are same as
BORDER-WIDTH and BORDER-COLOR, but do not suggest to use for the
reason:

   Add distinct controls for child frames' borders (Bug#45620)
   http://git.savannah.gnu.org/cgit/emacs.git/commit/?id=ff7b1a133bfa7f2614650f8551824ffaef13fadc

 (9) FONT, FOREGROUND-COLOR and BACKGROUND-COLOR

Posframe's font as well as foreground and background colors are
derived from the current frame by default, but can be overridden
using the FONT, FOREGROUND-COLOR and BACKGROUND-COLOR arguments,
respectively.

 (10) RESPECT-HEADER-LINE and RESPECT-MODE-LINE

By default, posframe will display no header-line, mode-line and
tab-line.  In case a header-line, mode-line or tab-line is
desired, users can set RESPECT-HEADER-LINE and RESPECT-MODE-LINE
to t.

 (11) INITIALIZE

INITIALIZE is a function with no argument.  It will run when
posframe buffer is first selected with `with-current-buffer'
in `posframe-show', and only run once (for performance reasons).

 (12) LINES-TRUNCATE

If LINES-TRUNCATE is non-nil, then lines will truncate in the
posframe instead of wrap.

 (13) OVERRIDE-PARAMETERS

OVERRIDE-PARAMETERS is very powful, *all* the valid frame parameters
used by posframe's frame can be overridden by it.

NOTE: some `posframe-show' arguments are not frame parameters, so they
can not be overrided by this argument.

 (14) TIMEOUT

TIMEOUT can specify the number of seconds after which the posframe
will auto-hide.

 (15) REFRESH

If REFRESH is a number, posframe's frame-size will be re-adjusted
every REFRESH seconds.

 (16) ACCEPT-FOCUS

When ACCEPT-FOCUS is non-nil, posframe will accept focus.
be careful, you may face some bugs when set it to non-nil.

 (17) HIDEHANDLER

HIDEHANDLER is a function, when it return t, posframe will be
hide, this function has a plist argument:

  (:posframe-buffer xxx
   :posframe-parent-buffer xxx)

The builtin hidehandler functions are listed below:

1. `posframe-hidehandler-when-buffer-switch'

 (18) REFPOSHANDLER

REFPOSHANDLER is a function, a reference position (most is
top-left of current frame) will be returned when call this
function.

when it is nil or it return nil, child-frame feature will be used
and reference position will be deal with in Emacs.

The user case I know at the moment is let ivy-posframe work well
in EXWM environment (let posframe show on the other appliction
window).

         DO NOT USE UNLESS NECESSARY!!!

An example parent frame poshandler function is:

1. `posframe-refposhandler-xwininfo'

 (19) Others

You can use `posframe-delete-all' to delete all posframes.

(fn BUFFER-OR-NAME &key STRING POSITION POSHANDLER POSHANDLER-EXTRA-INFO WIDTH HEIGHT MAX-WIDTH MAX-HEIGHT MIN-WIDTH MIN-HEIGHT X-PIXEL-OFFSET Y-PIXEL-OFFSET LEFT-FRINGE RIGHT-FRINGE BORDER-WIDTH BORDER-COLOR INTERNAL-BORDER-WIDTH INTERNAL-BORDER-COLOR FONT FOREGROUND-COLOR BACKGROUND-COLOR RESPECT-HEADER-LINE RESPECT-MODE-LINE INITIALIZE NO-PROPERTIES KEEP-RATIO LINES-TRUNCATE OVERRIDE-PARAMETERS TIMEOUT REFRESH ACCEPT-FOCUS HIDEHANDLER REFPOSHANDLER &allow-other-keys)" nil nil) (autoload (quote posframe-hide-all) "posframe" "Hide all posframe frames.

(fn)" t nil) (autoload (quote posframe-delete-all) "posframe" "Delete all posframe frames and buffers.

(fn)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "posframe" (quote ("posframe-")))) (autoload (quote posframe-benchmark) "posframe-benchmark" "Benchmark tool for posframe.

(fn)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "posframe-benchmark" (quote ("posframe-benchmark-alist")))) (provide (quote posframe-autoloads))) "cfrs" ((cfrs cfrs-autoloads) (autoload (quote cfrs-read) "cfrs" "Read a string using a pos-frame with given PROMPT and INITIAL-INPUT.

(fn PROMPT &optional INITIAL-INPUT)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "cfrs" (quote ("cfrs-")))) (provide (quote cfrs-autoloads))) "treemacs" ((treemacs-interface treemacs-core-utils treemacs-workspaces treemacs-macros treemacs-diagnostics treemacs-tags treemacs-customization treemacs-peek-mode treemacs-mode treemacs-project-follow-mode treemacs-mouse-interface treemacs-scope treemacs-file-management treemacs-hydras treemacs-themes treemacs-visuals treemacs-logging treemacs treemacs-icons treemacs-fringe-indicator treemacs-autoloads treemacs-compatibility treemacs-faces treemacs-header-line treemacs-follow-mode treemacs-dom treemacs-filewatch-mode treemacs-tag-follow-mode treemacs-rendering treemacs-bookmarks treemacs-persistence treemacs-extensions treemacs-async) (autoload (quote treemacs-version) "treemacs" "Return the `treemacs-version'.

(fn)" t nil) (autoload (quote treemacs) "treemacs" "Initialise or toggle treemacs.
* If the treemacs window is visible hide it.
* If a treemacs buffer exists, but is not visible show it.
* If no treemacs buffer exists for the current frame create and show it.
* If the workspace is empty additionally ask for the root path of the first
  project to add.

(fn)" t nil) (autoload (quote treemacs-find-file) "treemacs" "Find and focus the current file in the treemacs window.
If the current buffer has visits no file or with a prefix ARG ask for the
file instead.
Will show/create a treemacs buffers if it is not visible/does not exist.
For the most part only useful when `treemacs-follow-mode' is not active.

(fn &optional ARG)" t nil) (autoload (quote treemacs-find-tag) "treemacs" "Find and move point to the tag at point in the treemacs view.
Most likely to be useful when `treemacs-tag-follow-mode' is not active.

Will ask to change the treemacs root if the file to find is not under the
root.  If no treemacs buffer exists it will be created with the current file's
containing directory as root.  Will do nothing if the current buffer is not
visiting a file or Emacs cannot find any tags for the current file.

(fn)" t nil) (autoload (quote treemacs-select-window) "treemacs" "Select the treemacs window if it is visible.
Bring it to the foreground if it is not visible.
Initialise a new treemacs buffer as calling `treemacs' would if there is no
treemacs buffer for this frame.
Jump back to the previously used window if point is already in treemacs.

(fn)" t nil) (autoload (quote treemacs-show-changelog) "treemacs" "Show the changelog of treemacs.

(fn)" t nil) (autoload (quote treemacs-edit-workspaces) "treemacs" "Edit your treemacs workspaces and projects as an `org-mode' file.

(fn)" t nil) (autoload (quote treemacs-display-current-project-exclusively) "treemacs" "Display the current project, and *only* the current project.
Like `treemacs-add-and-display-current-project' this will add the current
project to treemacs based on either projectile, the built-in project.el, or the
current working directory.

However the 'exclusive' part means that it will make the current project the
only project, all other projects *will be removed* from the current workspace.

(fn)" t nil) (autoload (quote treemacs-add-and-display-current-project) "treemacs" "Open treemacs and add the current project root to the workspace.
The project is determined first by projectile (if treemacs-projectile is
installed), then by project.el, then by the current working directory.

If the project is already registered with treemacs just move point to its root.
An error message is displayed if the current buffer is not part of any project.

(fn)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs" (quote ("treemacs-version")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-async" (quote ("treemacs-")))) (autoload (quote treemacs-bookmark) "treemacs-bookmarks" "Find a bookmark in treemacs.
Only bookmarks marking either a file or a directory are offered for selection.
Treemacs will try to find and focus the given bookmark's location, in a similar
fashion to `treemacs-find-file'.

With a prefix argument ARG treemacs will also open the bookmarked location.

(fn &optional ARG)" t nil) (autoload (quote treemacs--bookmark-handler) "treemacs-bookmarks" "Open Treemacs into a bookmark RECORD.

(fn RECORD)" nil nil) (autoload (quote treemacs-add-bookmark) "treemacs-bookmarks" "Add the current node to Emacs' list of bookmarks.
For file and directory nodes their absolute path is saved.  Tag nodes
additionally also save the tag's position.  A tag can only be bookmarked if the
treemacs node is pointing to a valid buffer position.

(fn)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-bookmarks" (quote ("treemacs--")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-compatibility" (quote ("treemacs-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-core-utils" (quote ("treemacs-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-customization" (quote ("treemacs-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-diagnostics" (quote ("treemacs-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-dom" (quote ("treemacs-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-extensions" (quote ("treemacs-")))) (autoload (quote treemacs-delete-file) "treemacs-file-management" "Delete node at point.
A delete action must always be confirmed.  Directories are deleted recursively.
By default files are deleted by moving them to the trash.  With a prefix ARG
they will instead be wiped irreversibly.

(fn &optional ARG)" t nil) (autoload (quote treemacs-move-file) "treemacs-file-management" "Move file (or directory) at point.
Destination may also be a filename, in which case the moved file will also
be renamed.

(fn)" t nil) (autoload (quote treemacs-copy-file) "treemacs-file-management" "Copy file (or directory) at point.
Destination may also be a filename, in which case the copied file will also
be renamed.

(fn)" t nil) (autoload (quote treemacs-rename-file) "treemacs-file-management" "Rename the currently selected node.
Buffers visiting the renamed file or visiting a file inside a renamed directory
and windows showing them will be reloaded.  The list of recent files will
likewise be updated.

(fn)" t nil) (autoload (quote treemacs-create-file) "treemacs-file-management" "Create a new file.
Enter first the directory to create the new file in, then the new file's name.
The pre-selection for what directory to create in is based on the \"nearest\"
path to point - the containing directory for tags and files or the directory
itself, using $HOME when there is no path at or near point to grab.

(fn)" t nil) (autoload (quote treemacs-create-dir) "treemacs-file-management" "Create a new directory.
Enter first the directory to create the new dir in, then the new dir's name.
The pre-selection for what directory to create in is based on the \"nearest\"
path to point - the containing directory for tags and files or the directory
itself, using $HOME when there is no path at or near point to grab.

(fn)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-file-management" (quote ("treemacs-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-filewatch-mode" (quote ("treemacs-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-follow-mode" (quote ("treemacs-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-fringe-indicator" (quote ("treemacs-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-header-line" (quote ("treemacs-header-buttons-format")))) (autoload (quote treemacs-common-helpful-hydra) "treemacs-hydras" "Summon a helpful hydra to show you the treemacs keymap.

This hydra will show the most commonly used keybinds for treemacs.  For the more
advanced (probably rarely used keybinds) see `treemacs-advanced-helpful-hydra'.

The keybinds shown in this hydra are not static, but reflect the actual
keybindings currently in use (including evil mode).  If the hydra is unable to
find the key a command is bound to it will show a blank instead.

(fn)" t nil) (autoload (quote treemacs-advanced-helpful-hydra) "treemacs-hydras" "Summon a helpful hydra to show you the treemacs keymap.

This hydra will show the more advanced (rarely used) keybinds for treemacs.  For
the more commonly used keybinds see `treemacs-common-helpful-hydra'.

The keybinds shown in this hydra are not static, but reflect the actual
keybindings currently in use (including evil mode).  If the hydra is unable to
find the key a command is bound to it will show a blank instead.

(fn)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-hydras" (quote ("treemacs-helpful-hydra")))) (autoload (quote treemacs-resize-icons) "treemacs-icons" "Resize the current theme's icons to the given SIZE.

If SIZE is 'nil' the icons are not resized and will retain their default size of
22 pixels.

There is only one size, the icons are square and the aspect ratio will be
preserved when resizing them therefore width and height are the same.

Resizing the icons only works if Emacs was built with ImageMagick support, or if
using Emacs >= 27.1,which has native image resizing support.  If this is not the
case this function will not have any effect.

Custom icons are not taken into account, only the size of treemacs' own icons
png are changed.

(fn SIZE)" t nil) (autoload (quote treemacs-define-custom-icon) "treemacs-icons" "Define a custom ICON for the current theme to use for FILE-EXTENSIONS.

Note that treemacs has a very loose definition of what constitutes a file
extension - it's either everything past the last period, or just the file's full
name if there is no period.  This makes it possible to match file names like
'.gitignore' and 'Makefile'.

Additionally FILE-EXTENSIONS are also not case sensitive and will be stored in a
down-cased state.

(fn ICON &rest FILE-EXTENSIONS)" nil nil) (autoload (quote treemacs-define-custom-image-icon) "treemacs-icons" "Same as `treemacs-define-custom-icon' but for image icons instead of strings.
FILE is the path to an icon image (and not the actual icon string).
FILE-EXTENSIONS are all the (not case-sensitive) file extensions the icon
should be used for.

(fn FILE &rest FILE-EXTENSIONS)" nil nil) (autoload (quote treemacs-map-icons-with-auto-mode-alist) "treemacs-icons" "Remaps icons for EXTENSIONS according to `auto-mode-alist'.
EXTENSIONS should be a list of file extensions such that they match the regex
stored in `auto-mode-alist', for example '(\".cc\").
MODE-ICON-ALIST is an alist that maps which mode from `auto-mode-alist' should
be assigned which treemacs icon, for example
'((c-mode . treemacs-icon-c)
  (c++-mode . treemacs-icon-cpp))

(fn EXTENSIONS MODE-ICON-ALIST)" nil nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-icons" (quote ("treemacs-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-interface" (quote ("treemacs-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-logging" (quote ("treemacs-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-macros" (quote ("treemacs-")))) (autoload (quote treemacs-mode) "treemacs-mode" "A major mode for displaying the file system in a tree layout.

(fn)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-mode" (quote ("treemacs-")))) (autoload (quote treemacs-leftclick-action) "treemacs-mouse-interface" "Move focus to the clicked line.
Must be bound to a mouse click, or EVENT will not be supplied.

(fn EVENT)" t nil) (autoload (quote treemacs-doubleclick-action) "treemacs-mouse-interface" "Run the appropriate double-click action for the current node.
In the default configuration this means to do the same as `treemacs-RET-action'.

This function's exact configuration is stored in
`treemacs-doubleclick-actions-config'.

Must be bound to a mouse click, or EVENT will not be supplied.

(fn EVENT)" t nil) (autoload (quote treemacs-single-click-expand-action) "treemacs-mouse-interface" "A modified single-leftclick action that expands the clicked nodes.
Can be bound to <mouse1> if you prefer to expand nodes with a single click
instead of a double click.  Either way it must be bound to a mouse click, or
EVENT will not be supplied.

Clicking on icons will expand a file's tags, just like
`treemacs-leftclick-action'.

(fn EVENT)" t nil) (autoload (quote treemacs-dragleftclick-action) "treemacs-mouse-interface" "Drag a file/dir node to be opened in a window.
Must be bound to a mouse click, or EVENT will not be supplied.

(fn EVENT)" t nil) (autoload (quote treemacs-define-doubleclick-action) "treemacs-mouse-interface" "Define the behaviour of `treemacs-doubleclick-action'.
Determines that a button with a given STATE should lead to the execution of
ACTION.

The list of possible states can be found in `treemacs-valid-button-states'.
ACTION should be one of the `treemacs-visit-node-*' commands.

(fn STATE ACTION)" nil nil) (autoload (quote treemacs-node-buffer-and-position) "treemacs-mouse-interface" "Return source buffer or list of buffer and position for the current node.
This information can be used for future display.  Stay in the selected window
and ignore any prefix argument.

(fn &optional _)" t nil) (autoload (quote treemacs-rightclick-menu) "treemacs-mouse-interface" "Show a contextual right click menu based on click EVENT.

(fn EVENT)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-mouse-interface" (quote ("treemacs--")))) (defvar treemacs-peek-mode nil "Non-nil if Treemacs-Peek mode is enabled.
See the `treemacs-peek-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `treemacs-peek-mode'.") (custom-autoload (quote treemacs-peek-mode) "treemacs-peek-mode" nil) (autoload (quote treemacs-peek-mode) "treemacs-peek-mode" "Minor mode that allows you to peek at buffers before deciding to open them.

While the mode is active treemacs will automatically display the file at point,
without leving the treemacs window.

Peeking will stop when you leave the treemacs window, be it through a command
like `treemacs-RET-action' or some other window selection change.

Files' buffers that have been opened for peeking will be cleaned up if they did
not exist before peeking started.

The peeked window can be scrolled using
`treemacs-next/previous-line-other-window' and
`treemacs-next/previous-page-other-window'

(fn &optional ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-peek-mode" (quote ("treemacs--")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-persistence" (quote ("treemacs-")))) (defvar treemacs-project-follow-mode nil "Non-nil if Treemacs-Project-Follow mode is enabled.
See the `treemacs-project-follow-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `treemacs-project-follow-mode'.") (custom-autoload (quote treemacs-project-follow-mode) "treemacs-project-follow-mode" nil) (autoload (quote treemacs-project-follow-mode) "treemacs-project-follow-mode" "Toggle `treemacs-only-current-project-mode'.

This is a minor mode meant for those who do not care about treemacs' workspace
features, or its preference to work with multiple projects simultaneously.  When
enabled it will function as an automated version of
`treemacs-display-current-project-exclusively', making sure that, after a small
idle delay, the current project, and *only* the current project, is displayed in
treemacs.

The project detection is based on the current buffer, and will try to determine
the project using the following methods, in the order they are listed:

- the current projectile.el project, if `treemacs-projectile' is installed
- the current project.el project
- the current `default-directory'

The update will only happen when treemacs is in the foreground, meaning a
treemacs window must exist in the current scope.

This mode requires at least Emacs version 27 since it relies on
`window-buffer-change-functions' and `window-selection-change-functions'.

(fn &optional ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-project-follow-mode" (quote ("treemacs--")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-rendering" (quote ("treemacs-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-scope" (quote ("treemacs-")))) (autoload (quote treemacs--flatten&sort-imenu-index) "treemacs-tag-follow-mode" "Flatten current file's imenu index and sort it by tag position.
The tags are sorted into the order in which they appear, regardless of section
or nesting depth.

(fn)" nil nil) (defvar treemacs-tag-follow-mode nil "Non-nil if Treemacs-Tag-Follow mode is enabled.
See the `treemacs-tag-follow-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `treemacs-tag-follow-mode'.") (custom-autoload (quote treemacs-tag-follow-mode) "treemacs-tag-follow-mode" nil) (autoload (quote treemacs-tag-follow-mode) "treemacs-tag-follow-mode" "Toggle `treemacs-tag-follow-mode'.

This acts as more fine-grained alternative to `treemacs-follow-mode' and will
thus disable `treemacs-follow-mode' on activation.  When enabled treemacs will
focus not only the file of the current buffer, but also the tag at point.

The follow action is attached to Emacs' idle timer and will run
`treemacs-tag-follow-delay' seconds of idle time.  The delay value is not an
integer, meaning it accepts floating point values like 1.5.

Every time a tag is followed a re--scan of the imenu index is forced by
temporarily setting `imenu-auto-rescan' to t (though a cache is applied as long
as the buffer is unmodified).  This is necessary to assure that creation or
deletion of tags does not lead to errors and guarantees an always up-to-date tag
view.

Note that in order to move to a tag in treemacs the treemacs buffer's window
needs to be temporarily selected, which will reset blink-cursor-mode's timer if
it is enabled.  This will result in the cursor blinking seemingly pausing for a
short time and giving the appearance of the tag follow action lasting much
longer than it really does.

(fn &optional ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-tag-follow-mode" (quote ("treemacs--")))) (autoload (quote treemacs--expand-file-node) "treemacs-tags" "Open tag items for file BTN.
Recursively open all tags below BTN when RECURSIVE is non-nil.

(fn BTN &optional RECURSIVE)" nil nil) (autoload (quote treemacs--collapse-file-node) "treemacs-tags" "Close node given by BTN.
Remove all open tag entries under BTN when RECURSIVE.

(fn BTN &optional RECURSIVE)" nil nil) (autoload (quote treemacs--visit-or-expand/collapse-tag-node) "treemacs-tags" "Visit tag section BTN if possible, expand or collapse it otherwise.
Pass prefix ARG on to either visit or toggle action.

FIND-WINDOW is a special provision depending on this function's invocation
context and decides whether to find the window to display in (if the tag is
visited instead of the node being expanded).

On the one hand it can be called based on `treemacs-RET-actions-config' (or
TAB).  The functions in these configs are expected to find the windows they need
to display in themselves, so FIND-WINDOW must be t. On the other hand this
function is also called from the top level vist-node functions like
`treemacs-visit-node-vertical-split' which delegates to the
`treemacs--execute-button-action' macro which includes the determination of
the display window.

(fn BTN ARG FIND-WINDOW)" nil nil) (autoload (quote treemacs--expand-tag-node) "treemacs-tags" "Open tags node items for BTN.
Open all tag section under BTN when call is RECURSIVE.

(fn BTN &optional RECURSIVE)" nil nil) (autoload (quote treemacs--collapse-tag-node) "treemacs-tags" "Close tags node at BTN.
Remove all open tag entries under BTN when RECURSIVE.

(fn BTN &optional RECURSIVE)" nil nil) (autoload (quote treemacs--goto-tag) "treemacs-tags" "Go to the tag at BTN.

(fn BTN)" nil nil) (autoload (quote treemacs--create-imenu-index-function) "treemacs-tags" "The `imenu-create-index-function' for treemacs buffers.

(fn)" nil nil) (function-put (quote treemacs--create-imenu-index-function) (quote side-effect-free) (quote t)) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-tags" (quote ("treemacs--")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-themes" (quote ("treemacs-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-visuals" (quote ("treemacs-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "treemacs-workspaces" (quote ("treemacs-")))) (provide (quote treemacs-autoloads))) "company-lsp" ((company-lsp-autoloads company-lsp) (autoload (quote company-lsp) "company-lsp" "Define a company backend for lsp-mode.

See the documentation of `company-backends' for COMMAND and ARG.

(fn COMMAND &optional ARG &rest _)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company-lsp" (quote ("company-lsp-")))) (provide (quote company-lsp-autoloads))) "origami" ((origami origami-autoloads origami-parsers) (autoload (quote origami-mode) "origami" "Minor mode to selectively hide/show text in the current buffer.
With a prefix argument ARG, enable the mode if ARG is positive,
and disable it otherwise.  If called from Lisp, enable the mode
if ARG is omitted or nil.

Lastly, the normal hook `origami-mode-hook' is run using
`run-hooks'.

Key bindings:
\\{origami-mode-map}

(fn &optional ARG)" t nil) (defvar global-origami-mode nil "Non-nil if Global Origami mode is enabled.
See the `global-origami-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-origami-mode'.") (custom-autoload (quote global-origami-mode) "origami" nil) (autoload (quote global-origami-mode) "origami" "Toggle Origami mode in all buffers.
With prefix ARG, enable Global Origami mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Origami mode is enabled in all buffers where
`(lambda nil (origami-mode 1))' would do it.
See `origami-mode' for more information on Origami mode.

(fn &optional ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "origami" (quote ("origami-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "origami-parsers" (quote ("origami-")))) (provide (quote origami-autoloads))) "lsp-origami" ((lsp-origami-autoloads lsp-origami) (autoload (quote lsp-origami-try-enable) "lsp-origami" "Turn on `origami-mode' locally and try to enable `lsp-origami-mode'.

(fn)" t nil) (autoload (quote lsp-origami-mode) "lsp-origami" "Toggle code folding support for origami.

(fn &optional ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "lsp-origami" (quote ("lsp-origami--")))) (provide (quote lsp-origami-autoloads))) "go-mode" ((go-mode-autoloads go-mode) (autoload (quote go-mode) "go-mode" "Major mode for editing Go source text.

This mode provides (not just) basic editing capabilities for
working with Go code. It offers almost complete syntax
highlighting, indentation that is almost identical to gofmt and
proper parsing of the buffer content to allow features such as
navigation by function, manipulation of comments or detection of
strings.

In addition to these core features, it offers various features to
help with writing Go code. You can directly run buffer content
through gofmt, read godoc documentation from within Emacs, modify
and clean up the list of package imports or interact with the
Playground (uploading and downloading pastes).

The following extra functions are defined:

- `gofmt'
- `godoc' and `godoc-at-point'
- `go-import-add'
- `go-remove-unused-imports'
- `go-goto-arguments'
- `go-goto-docstring'
- `go-goto-function'
- `go-goto-function-name'
- `go-goto-imports'
- `go-goto-return-values'
- `go-goto-method-receiver'
- `go-play-buffer' and `go-play-region'
- `go-download-play'
- `godef-describe' and `godef-jump'
- `go-coverage'
- `go-set-project'
- `go-reset-gopath'

If you want to automatically run `gofmt' before saving a file,
add the following hook to your emacs configuration:

(add-hook 'before-save-hook #'gofmt-before-save)

If you want to use `godef-jump' instead of etags (or similar),
consider binding godef-jump to `M-.', which is the default key
for `find-tag':

(add-hook 'go-mode-hook (lambda ()
                          (local-set-key (kbd \"M-.\") #'godef-jump)))

Please note that godef is an external dependency. You can install
it with

go get github.com/rogpeppe/godef


If you're looking for even more integration with Go, namely
on-the-fly syntax checking, auto-completion and snippets, it is
recommended that you look at flycheck
(see URL `https://github.com/flycheck/flycheck') or flymake in combination
with goflymake (see URL `https://github.com/dougm/goflymake'), gocode
(see URL `https://github.com/nsf/gocode'), go-eldoc
(see URL `github.com/syohex/emacs-go-eldoc') and yasnippet-go
(see URL `https://github.com/dominikh/yasnippet-go')

(fn)" t nil) (add-to-list (quote auto-mode-alist) (cons "\\.go\\'" (quote go-mode))) (autoload (quote gofmt-before-save) "go-mode" "Add this to .emacs to run gofmt on the current buffer when saving:
(add-hook 'before-save-hook 'gofmt-before-save).

Note that this will cause \342\200\230go-mode\342\200\231 to get loaded the first time
you save any file, kind of defeating the point of autoloading.

(fn)" t nil) (autoload (quote godoc) "go-mode" "Show Go documentation for QUERY, much like \\<go-mode-map>\\[man].

(fn QUERY)" t nil) (autoload (quote go-download-play) "go-mode" "Download a paste from the playground and insert it in a Go buffer.
Tries to look for a URL at point.

(fn URL)" t nil) (autoload (quote go-dot-mod-mode) "go-mode" "A major mode for editing go.mod files.

(fn)" t nil) (add-to-list (quote auto-mode-alist) (quote ("go\\.mod\\'" . go-dot-mod-mode))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "go-mode" (quote ("gofmt" "god" "go-")))) (provide (quote go-mode-autoloads))) "epl" ((epl epl-autoloads) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "epl" (quote ("epl-")))) (provide (quote epl-autoloads))) "pkg-info" ((pkg-info-autoloads pkg-info) (autoload (quote pkg-info-library-original-version) "pkg-info" "Get the original version in the header of LIBRARY.

The original version is stored in the X-Original-Version header.
This header is added by the MELPA package archive to preserve
upstream version numbers.

LIBRARY is either a symbol denoting a named feature, or a library
name as string.

If SHOW is non-nil, show the version in the minibuffer.

Return the version from the header of LIBRARY as list.  Signal an
error if the LIBRARY was not found or had no X-Original-Version
header.

See Info node `(elisp)Library Headers' for more information
about library headers.

(fn LIBRARY &optional SHOW)" t nil) (autoload (quote pkg-info-library-version) "pkg-info" "Get the version in the header of LIBRARY.

LIBRARY is either a symbol denoting a named feature, or a library
name as string.

If SHOW is non-nil, show the version in the minibuffer.

Return the version from the header of LIBRARY as list.  Signal an
error if the LIBRARY was not found or had no proper header.

See Info node `(elisp)Library Headers' for more information
about library headers.

(fn LIBRARY &optional SHOW)" t nil) (autoload (quote pkg-info-defining-library-original-version) "pkg-info" "Get the original version of the library defining FUNCTION.

The original version is stored in the X-Original-Version header.
This header is added by the MELPA package archive to preserve
upstream version numbers.

If SHOW is non-nil, show the version in mini-buffer.

This function is mainly intended to find the version of a major
or minor mode, i.e.

   (pkg-info-defining-library-version 'flycheck-mode)

Return the version of the library defining FUNCTION.  Signal an
error if FUNCTION is not a valid function, if its defining
library was not found, or if the library had no proper version
header.

(fn FUNCTION &optional SHOW)" t nil) (autoload (quote pkg-info-defining-library-version) "pkg-info" "Get the version of the library defining FUNCTION.

If SHOW is non-nil, show the version in mini-buffer.

This function is mainly intended to find the version of a major
or minor mode, i.e.

   (pkg-info-defining-library-version 'flycheck-mode)

Return the version of the library defining FUNCTION.  Signal an
error if FUNCTION is not a valid function, if its defining
library was not found, or if the library had no proper version
header.

(fn FUNCTION &optional SHOW)" t nil) (autoload (quote pkg-info-package-version) "pkg-info" "Get the version of an installed PACKAGE.

If SHOW is non-nil, show the version in the minibuffer.

Return the version as list, or nil if PACKAGE is not installed.

(fn PACKAGE &optional SHOW)" t nil) (autoload (quote pkg-info-version-info) "pkg-info" "Obtain complete version info for LIBRARY and PACKAGE.

LIBRARY is a symbol denoting a named feature, or a library name
as string.  PACKAGE is a symbol denoting an ELPA package.  If
omitted or nil, default to LIBRARY.

If SHOW is non-nil, show the version in the minibuffer.

When called interactively, prompt for LIBRARY.  When called
interactively with prefix argument, prompt for PACKAGE as well.

Return a string with complete version information for LIBRARY.
This version information contains the version from the headers of
LIBRARY, and the version of the installed PACKAGE, the LIBRARY is
part of.  If PACKAGE is not installed, or if the PACKAGE version
is the same as the LIBRARY version, do not include a package
version.

(fn LIBRARY &optional PACKAGE SHOW)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "pkg-info" (quote ("pkg-info-")))) (provide (quote pkg-info-autoloads))) "let-alist" ((let-alist-autoloads let-alist) (autoload (quote let-alist) "let-alist" "Let-bind dotted symbols to their cdrs in ALIST and execute BODY.
Dotted symbol is any symbol starting with a `.'.  Only those present
in BODY are let-bound and this search is done at compile time.

For instance, the following code

  (let-alist alist
    (if (and .title .body)
        .body
      .site
      .site.contents))

essentially expands to

  (let ((.title (cdr (assq \\='title alist)))
        (.body  (cdr (assq \\='body alist)))
        (.site  (cdr (assq \\='site alist)))
        (.site.contents (cdr (assq \\='contents (cdr (assq \\='site alist))))))
    (if (and .title .body)
        .body
      .site
      .site.contents))

If you nest `let-alist' invocations, the inner one can't access
the variables of the outer one.  You can, however, access alists
inside the original alist by using dots inside the symbol, as
displayed in the example above.

(fn ALIST &rest BODY)" nil t) (function-put (quote let-alist) (quote lisp-indent-function) (quote 1)) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "let-alist" (quote ("let-alist--")))) (provide (quote let-alist-autoloads))) "flycheck" ((flycheck flycheck-buttercup flycheck-autoloads flycheck-ert) (autoload (quote flycheck-manual) "flycheck" "Open the Flycheck manual.

(fn)" t nil) (autoload (quote flycheck-mode) "flycheck" "Flycheck is a minor mode for on-the-fly syntax checking.

In `flycheck-mode' the buffer is automatically syntax-checked
using the first suitable syntax checker from `flycheck-checkers'.
Use `flycheck-select-checker' to select a checker for the current
buffer manually.

If you run into issues, use `\\[flycheck-verify-setup]' to get help.

Flycheck supports many languages out of the box, and many
additional ones are available on MELPA.  Adding new ones is very
easy.  Complete documentation is available online at URL
`https://www.flycheck.org/en/latest/'.  Please report issues and
request features at URL `https://github.com/flycheck/flycheck'.

Flycheck displays its status in the mode line.  In the default
configuration, it looks like this:

`FlyC'     This buffer has not been checked yet.
`FlyC-'    Flycheck doesn't have a checker for this buffer.
`FlyC*'    Flycheck is running.  Expect results soon!
`FlyC:3|2' This buffer contains three warnings and two errors.
           Use `\\[flycheck-list-errors]' to see the list.

You may also see the following icons:
`FlyC!'    The checker crashed.
`FlyC.'    The last syntax check was manually interrupted.
`FlyC?'    The checker did something unexpected, like exiting with 1
           but returning no errors.

The following keybindings are available in `flycheck-mode':

\\{flycheck-mode-map}
(you can change the prefix by customizing
`flycheck-keymap-prefix')

If called interactively, enable Flycheck mode if ARG is positive,
and disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it if
ARG is \342\200\230toggle\342\200\231; disable the mode otherwise.

(fn &optional ARG)" t nil) (defvar global-flycheck-mode nil "Non-nil if Global Flycheck mode is enabled.
See the `global-flycheck-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-flycheck-mode'.") (custom-autoload (quote global-flycheck-mode) "flycheck" nil) (autoload (quote global-flycheck-mode) "flycheck" "Toggle Flycheck mode in all buffers.
With prefix ARG, enable Global Flycheck mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Flycheck mode is enabled in all buffers where
`flycheck-mode-on-safe' would do it.
See `flycheck-mode' for more information on Flycheck mode.

(fn &optional ARG)" t nil) (autoload (quote flycheck-define-error-level) "flycheck" "Define a new error LEVEL with PROPERTIES.

The following PROPERTIES constitute an error level:

`:severity SEVERITY'
     A number denoting the severity of this level.  The higher
     the number, the more severe is this level compared to other
     levels.  Defaults to 0; info is -10, warning is 10, and
     error is 100.

     The severity is used by `flycheck-error-level-<' to
     determine the ordering of errors according to their levels.

`:compilation-level LEVEL'

     A number indicating the broad class of messages that errors
     at this level belong to: one of 0 (info), 1 (warning), or
     2 or nil (error).  Defaults to nil.

     This is used by `flycheck-checker-pattern-to-error-regexp'
     to map error levels into `compilation-mode''s hierarchy and
     to get proper highlighting of errors in `compilation-mode'.

`:overlay-category CATEGORY'
     A symbol denoting the overlay category to use for error
     highlight overlays for this level.  See Info
     node `(elisp)Overlay Properties' for more information about
     overlay categories.

     A category for an error level overlay should at least define
     the `face' property, for error highlighting.  Another useful
     property for error level categories is `priority', to
     influence the stacking of multiple error level overlays.

`:fringe-bitmap BITMAPS'
     A fringe bitmap symbol denoting the bitmap to use for fringe
     indicators for this level, or a cons of two bitmaps (one for
     narrow fringes and one for wide fringes).  See Info node
     `(elisp)Fringe Bitmaps' for more information about fringe
     bitmaps, including a list of built-in fringe bitmaps.

`:fringe-face FACE'
     A face symbol denoting the face to use for fringe indicators
     for this level.

`:margin-spec SPEC'
     A display specification indicating what to display in the
     margin when `flycheck-indication-mode' is `left-margin' or
     `right-margin'.  See Info node `(elisp)Displaying in the
     Margins'.  If omitted, Flycheck generates an image spec from
     the fringe bitmap.

`:error-list-face FACE'
     A face symbol denoting the face to use for messages of this
     level in the error list.  See `flycheck-list-errors'.

(fn LEVEL &rest PROPERTIES)" nil nil) (function-put (quote flycheck-define-error-level) (quote lisp-indent-function) (quote 1)) (autoload (quote flycheck-define-command-checker) "flycheck" "Define SYMBOL as syntax checker to run a command.

Define SYMBOL as generic syntax checker via
`flycheck-define-generic-checker', which uses an external command
to check the buffer.  SYMBOL and DOCSTRING are the same as for
`flycheck-define-generic-checker'.

In addition to the properties understood by
`flycheck-define-generic-checker', the following PROPERTIES
constitute a command syntax checker.  Unless otherwise noted, all
properties are mandatory.  Note that the default `:error-filter'
of command checkers is `flycheck-sanitize-errors'.

`:command COMMAND'
     The command to run for syntax checking.

     COMMAND is a list of the form `(EXECUTABLE [ARG ...])'.

     EXECUTABLE is a string with the executable of this syntax
     checker.  It can be overridden with the variable
     `flycheck-SYMBOL-executable'.  Note that this variable is
     NOT implicitly defined by this function.  Use
     `flycheck-def-executable-var' to define this variable.

     Each ARG is an argument to the executable, either as string,
     or as special symbol or form for
     `flycheck-substitute-argument', which see.

`:error-patterns PATTERNS'
     A list of patterns to parse the output of the `:command'.

     Each ITEM in PATTERNS is a list `(LEVEL SEXP ...)', where
     LEVEL is a Flycheck error level (see
     `flycheck-define-error-level'), followed by one or more RX
     `SEXP's which parse an error of that level and extract line,
     column, file name and the message.

     See `rx' for general information about RX, and
     `flycheck-rx-to-string' for some special RX forms provided
     by Flycheck.

     All patterns are applied in the order of declaration to the
     whole output of the syntax checker.  Output already matched
     by a pattern will not be matched by subsequent patterns.  In
     other words, the first pattern wins.

     This property is optional.  If omitted, however, an
     `:error-parser' is mandatory.

`:error-parser FUNCTION'
     A function to parse errors with.

     The function shall accept three arguments OUTPUT CHECKER
     BUFFER.  OUTPUT is the syntax checker output as string,
     CHECKER the syntax checker that was used, and BUFFER a
     buffer object representing the checked buffer.  The function
     must return a list of `flycheck-error' objects parsed from
     OUTPUT.

     This property is optional.  If omitted, it defaults to
     `flycheck-parse-with-patterns'.  In this case,
     `:error-patterns' is mandatory.

`:standard-input t'
     Whether to send the buffer contents on standard input.

     If this property is given and has a non-nil value, send the
     contents of the buffer on standard input.

     Defaults to nil.

Note that you may not give `:start', `:interrupt', and
`:print-doc' for a command checker.  You can give a custom
`:verify' function, though, whose results will be appended to the
default `:verify' function of command checkers.

(fn SYMBOL DOCSTRING &rest PROPERTIES)" nil nil) (function-put (quote flycheck-define-command-checker) (quote lisp-indent-function) (quote 1)) (function-put (quote flycheck-define-command-checker) (quote doc-string-elt) (quote 2)) (autoload (quote flycheck-def-config-file-var) "flycheck" "Define SYMBOL as config file variable for CHECKER, with default FILE-NAME.

SYMBOL is declared as customizable variable using `defcustom', to
provide configuration files for the given syntax CHECKER.
CUSTOM-ARGS are forwarded to `defcustom'.

FILE-NAME is the initial value of the new variable.  If omitted,
the default value is nil.  It can be either a string or a list of
strings.

Use this together with the `config-file' form in the `:command'
argument to `flycheck-define-checker'.

(fn SYMBOL CHECKER &optional FILE-NAME &rest CUSTOM-ARGS)" nil t) (function-put (quote flycheck-def-config-file-var) (quote lisp-indent-function) (quote 3)) (autoload (quote flycheck-def-option-var) "flycheck" "Define SYMBOL as option variable with INIT-VALUE for CHECKER.

SYMBOL is declared as customizable variable using `defcustom', to
provide an option for the given syntax CHECKERS (a checker or a
list of checkers).  INIT-VALUE is the initial value of the
variable, and DOCSTRING is its docstring.  CUSTOM-ARGS are
forwarded to `defcustom'.

Use this together with the `option', `option-list' and
`option-flag' forms in the `:command' argument to
`flycheck-define-checker'.

(fn SYMBOL INIT-VALUE CHECKERS DOCSTRING &rest CUSTOM-ARGS)" nil t) (function-put (quote flycheck-def-option-var) (quote lisp-indent-function) (quote 3)) (function-put (quote flycheck-def-option-var) (quote doc-string-elt) (quote 4)) (autoload (quote flycheck-define-checker) "flycheck" "Define SYMBOL as command syntax checker with DOCSTRING and PROPERTIES.

Like `flycheck-define-command-checker', but PROPERTIES must not
be quoted.  Also, implicitly define the executable variable for
SYMBOL with `flycheck-def-executable-var'.

(fn SYMBOL DOCSTRING &rest PROPERTIES)" nil t) (function-put (quote flycheck-define-checker) (quote lisp-indent-function) (quote 1)) (function-put (quote flycheck-define-checker) (quote doc-string-elt) (quote 2)) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "flycheck" (quote ("flycheck-" "list-flycheck-errors" "help-flycheck-checker-d")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "flycheck-buttercup" (quote ("flycheck-buttercup-format-error-list")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "flycheck-ert" (quote ("flycheck-er")))) (provide (quote flycheck-autoloads))) "go-guru" ((go-guru-autoloads go-guru) (autoload (quote go-guru-set-scope) "go-guru" "Set the scope for the Go guru, prompting the user to edit the previous scope.

The scope restricts analysis to the specified packages.
Its value is a comma-separated list of patterns of these forms:
	golang.org/x/tools/cmd/guru     # a single package
	golang.org/x/tools/...          # all packages beneath dir
	...                             # the entire workspace.

A pattern preceded by '-' is negative, so the scope
	encoding/...,-encoding/xml
matches all encoding packages except encoding/xml.

(fn)" t nil) (autoload (quote go-guru-callees) "go-guru" "Show possible callees of the function call at the current point.

(fn)" t nil) (autoload (quote go-guru-callers) "go-guru" "Show the set of callers of the function containing the current point.

(fn)" t nil) (autoload (quote go-guru-callstack) "go-guru" "Show an arbitrary path from a root of the call graph to the
function containing the current point.

(fn)" t nil) (autoload (quote go-guru-definition) "go-guru" "Jump to the definition of the selected identifier.

(fn &optional OTHER-WINDOW)" t nil) (autoload (quote go-guru-definition-other-window) "go-guru" "Jump to the defintion of the selected identifier in another window

(fn)" t nil) (autoload (quote go-guru-describe) "go-guru" "Describe the selected syntax, its kind, type and methods.

(fn)" t nil) (autoload (quote go-guru-pointsto) "go-guru" "Show what the selected expression points to.

(fn)" t nil) (autoload (quote go-guru-implements) "go-guru" "Describe the 'implements' relation for types in the package
containing the current point.

(fn)" t nil) (autoload (quote go-guru-freevars) "go-guru" "Enumerate the free variables of the current selection.

(fn)" t nil) (autoload (quote go-guru-peers) "go-guru" "Enumerate the set of possible corresponding sends/receives for
this channel receive/send operation.

(fn)" t nil) (autoload (quote go-guru-referrers) "go-guru" "Enumerate all references to the object denoted by the selected
identifier.

(fn)" t nil) (autoload (quote go-guru-whicherrs) "go-guru" "Show globals, constants and types to which the selected
expression (of type 'error') may refer.

(fn)" t nil) (autoload (quote go-guru-unhighlight-identifiers) "go-guru" "Remove highlights from previously highlighted identifier.

(fn)" nil nil) (autoload (quote go-guru-hl-identifier) "go-guru" "Highlight all instances of the identifier under point. Removes
highlights from previously highlighted identifier.

(fn)" t nil) (autoload (quote go-guru-hl-identifier-mode) "go-guru" "Highlight instances of the identifier at point after a short
timeout.

(fn &optional ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "go-guru" (quote ("go-guru-")))) (provide (quote go-guru-autoloads))) "go-rename" ((go-rename go-rename-autoloads) (autoload (quote go-rename) "go-rename" "Rename the entity denoted by the identifier at point, using
the `gorename' tool. With FORCE, call `gorename' with the
`-force' flag.

(fn NEW-NAME &optional FORCE)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "go-rename" (quote ("go-")))) (provide (quote go-rename-autoloads))) "restclient" ((restclient restclient-autoloads) (autoload (quote restclient-http-send-current) "restclient" "Sends current request.
Optional argument RAW don't reformat response if t.
Optional argument STAY-IN-WINDOW do not move focus to response buffer if t.

(fn &optional RAW STAY-IN-WINDOW)" t nil) (autoload (quote restclient-http-send-current-raw) "restclient" "Sends current request and get raw result (no reformatting or syntax highlight of XML, JSON or images).

(fn)" t nil) (autoload (quote restclient-http-send-current-stay-in-window) "restclient" "Send current request and keep focus in request window.

(fn)" t nil) (autoload (quote restclient-mode) "restclient" "Turn on restclient mode.

(fn)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "restclient" (quote ("restclient-")))) (provide (quote restclient-autoloads))) "know-your-http-well" ((http-status-codes http-relations know-your-http-well-autoloads http-methods media-types http-headers know-your-http-well) (autoload (quote http-header) "http-headers" "Display the meaning of an HTTP header

(fn HEADER)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "http-headers" (quote ("http-headers")))) (autoload (quote http-method) "http-methods" "Display the meaning of an HTTP method

(fn METHOD)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "http-methods" (quote ("http-methods")))) (autoload (quote http-relation) "http-relations" "Display the meaning of an HTTP relation

(fn RELATION)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "http-relations" (quote ("http-relations")))) (autoload (quote http-status-code) "http-status-codes" "Display the meaning of an HTTP status code or phrase

(fn STATUS)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "http-status-codes" (quote ("http-status")))) (autoload (quote media-type) "media-types" "Display the template of a media-type

(fn MEDIA-TYPE)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "media-types" (quote ("media-types")))) (provide (quote know-your-http-well-autoloads))) "company-restclient" ((company-restclient-autoloads company-restclient) (autoload (quote company-restclient) "company-restclient" "`company-mode' completion back-end for `restclient-mode'.
Provide completion info according to COMMAND and ARG.  IGNORED, not used.

(fn COMMAND &optional ARG &rest IGNORED)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "company-restclient" (quote ("company-restclient-")))) (provide (quote company-restclient-autoloads))) "smooth-scrolling" ((smooth-scrolling smooth-scrolling-autoloads) (defvar smooth-scrolling-mode nil "Non-nil if Smooth-Scrolling mode is enabled.
See the `smooth-scrolling-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `smooth-scrolling-mode'.") (custom-autoload (quote smooth-scrolling-mode) "smooth-scrolling" nil) (autoload (quote smooth-scrolling-mode) "smooth-scrolling" "Make emacs scroll smoothly

(fn &optional ARG)" t nil) (defvar smooth-scroll-margin 10 "Number of lines of visible margin at the top and bottom of a window.
If the point is within these margins, then scrolling will occur
smoothly for `previous-line' at the top of the window, and for
`next-line' at the bottom.

This is very similar in its goal to `scroll-margin'.  However, it
is implemented by activating `smooth-scroll-down' and
`smooth-scroll-up' advise via `defadvice' for `previous-line' and
`next-line' respectively.  As a result it avoids problems
afflicting `scroll-margin', such as a sudden jump and unexpected
highlighting of a region when the mouse is clicked in the margin.

Scrolling only occurs when the point is closer to the window
boundary it is heading for (top or bottom) than the middle of the
window.  This is to intelligently handle the case where the
margins cover the whole buffer (e.g. `smooth-scroll-margin' set
to 5 and `window-height' returning 10 or less).

See also `smooth-scroll-strict-margins'.") (custom-autoload (quote smooth-scroll-margin) "smooth-scrolling" t) (defvar smooth-scroll-strict-margins t "If true, the advice code supporting `smooth-scroll-margin'
will use `count-screen-lines' to determine the number of
*visible* lines between the point and the window top/bottom,
rather than `count-lines' which obtains the number of actual
newlines.  This is because there might be extra newlines hidden
by a mode such as folding-mode, outline-mode, org-mode etc., or
fewer due to very long lines being displayed wrapped when
`truncate-lines' is nil.

However, using `count-screen-lines' can supposedly cause
performance issues in buffers with extremely long lines.  Setting
`cache-long-line-scans' may be able to address this;
alternatively you can set this variable to nil so that the advice
code uses `count-lines', and put up with the fact that sometimes
the point will be allowed to stray into the margin.") (custom-autoload (quote smooth-scroll-strict-margins) "smooth-scrolling" t) (autoload (quote enable-smooth-scroll-for-function) "smooth-scrolling" "Define advice on FUNC to do smooth scrolling.

This adds after advice with name `smooth-scroll' to FUNC.

Note that the advice will not have an effect unless
`smooth-scrolling-mode' is enabled.

(fn FUNC)" nil t) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "smooth-scrolling" (quote ("do-smooth-scroll" "disable-smooth-scroll-for-function" "enable-smooth-scroll-for-function-conditionally" "window-is-at-bob-p" "smooth-scroll-")))) (provide (quote smooth-scrolling-autoloads))) "yaml-mode" ((yaml-mode-autoloads yaml-mode) (let ((loads (get (quote yaml) (quote custom-loads)))) (if (member (quote "yaml-mode") loads) nil (put (quote yaml) (quote custom-loads) (cons (quote "yaml-mode") loads)))) (autoload (quote yaml-mode) "yaml-mode" "Simple mode to edit YAML.

\\{yaml-mode-map}

(fn)" t nil) (add-to-list (quote auto-mode-alist) (quote ("\\.\\(e?ya?\\|ra\\)ml\\'" . yaml-mode))) (add-to-list (quote magic-mode-alist) (quote ("^%YAML\\s-+[0-9]+\\.[0-9]+\\(\\s-+#\\|\\s-*$\\)" . yaml-mode))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "yaml-mode" (quote ("yaml-")))) (provide (quote yaml-mode-autoloads))) "docker-compose-mode" ((docker-compose-mode docker-compose-mode-autoloads) (autoload (quote docker-compose-mode) "docker-compose-mode" "Major mode to edit docker-compose files.

(fn)" t nil) (add-to-list (quote auto-mode-alist) (quote ("docker-compose[^/]*\\.ya?ml\\'" . docker-compose-mode))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "docker-compose-mode" (quote ("docker-compose-")))) (provide (quote docker-compose-mode-autoloads))) "dockerfile-mode" ((dockerfile-mode dockerfile-mode-autoloads) (autoload (quote dockerfile-build-buffer) "dockerfile-mode" "Build an image called IMAGE-NAME based upon the buffer.

If prefix arg NO-CACHE is set, don't cache the image.
The build string will be of the format:
`sudo docker build --no-cache --tag IMAGE-NAME --build-args arg1.. -f filename directory`

(fn IMAGE-NAME &optional NO-CACHE)" t nil) (autoload (quote dockerfile-build-no-cache-buffer) "dockerfile-mode" "Build an image called IMAGE-NAME based upon the buffer without cache.

(fn IMAGE-NAME)" t nil) (autoload (quote dockerfile-mode) "dockerfile-mode" "A major mode to edit Dockerfiles.
\\{dockerfile-mode-map}

(fn)" t nil) (add-to-list (quote auto-mode-alist) (quote ("/Dockerfile\\(?:\\.[^/\\]*\\)?\\'" . dockerfile-mode))) (add-to-list (quote auto-mode-alist) (quote ("\\.dockerfile\\'" . dockerfile-mode))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "dockerfile-mode" (quote ("dockerfile-")))) (provide (quote dockerfile-mode-autoloads))) "go-fill-struct" ((go-fill-struct-autoloads go-fill-struct) (autoload (quote go-fill-struct) "go-fill-struct" "Fill go struct at point.

(fn)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "go-fill-struct" (quote ("go-fill-struct--buf")))) (provide (quote go-fill-struct-autoloads))) "yasnippet" ((yasnippet-autoloads yasnippet) (autoload (quote yas-minor-mode) "yasnippet" "Toggle YASnippet mode.

When YASnippet mode is enabled, `yas-expand', normally bound to
the TAB key, expands snippets of code depending on the major
mode.

With no argument, this command toggles the mode.
positive prefix argument turns on the mode.
Negative prefix argument turns off the mode.

Key bindings:
\\{yas-minor-mode-map}

(fn &optional ARG)" t nil) (defvar yas-global-mode nil "Non-nil if Yas-Global mode is enabled.
See the `yas-global-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `yas-global-mode'.") (custom-autoload (quote yas-global-mode) "yasnippet" nil) (autoload (quote yas-global-mode) "yasnippet" "Toggle Yas minor mode in all buffers.
With prefix ARG, enable Yas-Global mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Yas minor mode is enabled in all buffers where
`yas-minor-mode-on' would do it.
See `yas-minor-mode' for more information on Yas minor mode.

(fn &optional ARG)" t nil) (autoload (quote snippet-mode) "yasnippet" "A mode for editing yasnippets" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "yasnippet" (quote ("yas" "help-snippet-def" "snippet-mode-map")))) (provide (quote yasnippet-autoloads))) "yasnippet-snippets" ((yasnippet-snippets-autoloads yasnippet-snippets) (autoload (quote yasnippet-snippets-initialize) "yasnippet-snippets" "Load the `yasnippet-snippets' snippets directory.

(fn)" nil nil) (eval-after-load (quote yasnippet) (quote (yasnippet-snippets-initialize))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "yasnippet-snippets" (quote ("yasnippet-snippets-")))) (provide (quote yasnippet-snippets-autoloads))) "rich-minority" ((rich-minority rich-minority-autoloads) (autoload (quote rm--mode-list-as-string-list) "rich-minority" "Return `minor-mode-list' as a simple list of strings.

(fn)" nil nil) (defvar rich-minority-mode nil "Non-nil if Rich minority mode is enabled.
See the `rich-minority-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `rich-minority-mode'.") (custom-autoload (quote rich-minority-mode) "rich-minority" nil) (autoload (quote rich-minority-mode) "rich-minority" "Toggle Rich minority mode on or off.
With a prefix argument ARG, enable Rich minority mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil, and toggle it if ARG is `toggle'.
\\{rich-minority-mode-map}

(fn &optional ARG)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "rich-minority" (quote ("rm-")))) (provide (quote rich-minority-autoloads))) "diminish" ((diminish diminish-autoloads) (autoload (quote diminish) "diminish" "Diminish mode-line display of minor mode MODE to TO-WHAT (default \"\").

Interactively, enter (with completion) the name of any minor mode, followed
on the next line by what you want it diminished to (default empty string).
The response to neither prompt should be quoted.  However, in Lisp code,
both args must be quoted, the first as a symbol, the second as a string,
as in (diminish 'jiggle-mode \" Jgl\").

The mode-line displays of minor modes usually begin with a space, so
the modes' names appear as separate words on the mode line.  However, if
you're having problems with a cramped mode line, you may choose to use single
letters for some modes, without leading spaces.  Capitalizing them works
best; if you then diminish some mode to \"X\" but have `abbrev-mode' enabled as
well, you'll get a display like \"AbbrevX\".  This function prepends a space
to TO-WHAT if it's > 1 char long & doesn't already begin with a space.

(fn MODE &optional TO-WHAT)" t nil) (autoload (quote diminish-undo) "diminish" "Restore mode-line display of diminished mode MODE to its minor-mode value.
Do nothing if the arg is a minor mode that hasn't been diminished.

Interactively, enter (with completion) the name of any diminished mode (a
mode that was formerly a minor mode on which you invoked \\[diminish]).
To restore all diminished modes to minor status, answer `diminished-modes'.
The response to the prompt shouldn't be quoted.  However, in Lisp code,
the arg must be quoted as a symbol, as in (diminish-undo 'diminished-modes).

(fn MODE)" t nil) (autoload (quote diminished-modes) "diminish" "Echo all active diminished or minor modes as if they were minor.
The display goes in the echo area; if it's too long even for that,
you can see the whole thing in the *Messages* buffer.
This doesn't change the status of any modes; it just lets you see
what diminished modes would be on the mode-line if they were still minor.

(fn)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "diminish" (quote ("diminish")))) (provide (quote diminish-autoloads))) "zoom-window" ((zoom-window-autoloads zoom-window) (autoload (quote zoom-window-setup) "zoom-window" "To work with elscreen or persp-mode.

(fn)" nil nil) (autoload (quote zoom-window-zoom) "zoom-window" "Zoom the current window.

(fn)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "zoom-window" (quote ("zoom-window-")))) (provide (quote zoom-window-autoloads))) "vlf" ((vlf-base vlf-autoloads vlf-occur vlf-write vlf-ediff vlf-follow vlf vlf-search vlf-tune vlf-setup) (autoload (quote vlf) "vlf" "View Large FILE in batches.  When MINIMAL load just a few bytes.
You can customize number of bytes displayed by customizing
`vlf-batch-size'.
Return newly created buffer.

(fn FILE &optional MINIMAL)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "vlf" (quote ("vlf-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "vlf-base" (quote ("vlf-")))) (autoload (quote vlf-ediff-files) "vlf-ediff" "Run batch by batch ediff over FILE-A and FILE-B.
Files are processed with VLF with BATCH-SIZE chunks.
Requesting next or previous difference at the end or beginning
respectively of difference list, runs ediff over the adjacent chunks.

(fn FILE-A FILE-B BATCH-SIZE)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "vlf-ediff" (quote ("vlf-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "vlf-follow" (quote ("vlf-")))) (autoload (quote vlf-occur-load) "vlf-occur" "Load serialized `vlf-occur' results from current buffer.

(fn)" t nil) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "vlf-occur" (quote ("vlf-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "vlf-search" (quote ("vlf-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "vlf-setup" (quote ("dired-vlf" "vlf-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "vlf-tune" (quote ("vlf-")))) (if (fboundp (quote register-definition-prefixes)) (register-definition-prefixes "vlf-write" (quote ("vlf-")))) (provide (quote vlf-autoloads)))))

#s(hash-table size 65 test eq rehash-size 1.5 rehash-threshold 0.8125 data (org-elpa #s(hash-table size 97 test equal rehash-size 1.5 rehash-threshold 0.8125 data (version 9 "melpa" nil "gnu-elpa-mirror" nil "el-get" nil "emacsmirror-mirror" nil "straight" nil "use-package" nil "bind-key" nil "evil" nil "goto-chg" nil "cl-lib" nil "evil-collection" nil "annalist" nil "solarized-theme" nil "dash" nil "better-jumper" nil "neotree" nil "all-the-icons" nil "ace-window" nil "avy" nil "airline-themes" nil "powerline" nil "spaceline" nil "s" nil "spaceline-config" nil "rainbow-delimiters" nil "f" nil "undo-tree" nil "path-headerline-mode" nil "powerline-evil" nil "evil-matchit" nil "evil-leader" nil "easy-motion" nil "evil-easymotion" nil "which-key" nil "remind-bindings" nil "omni-quotes" nil "omni-log" nil "ht" nil "popwin" nil "map" nil "company" nil "ido-completing-read+" nil "seq" nil "memoize" nil "lsp-mode" nil "spinner" nil "markdown-mode" nil "lv" nil "lsp-ui" nil "esup" nil "treemacs" nil "pfuture" nil "hydra" nil "cfrs" nil "posframe" nil "company-lsp" nil "lsp-origami" nil "origami" nil "lsp-go" nil "go-mode" nil "lsp-html" nil "flycheck" nil "pkg-info" nil "epl" nil "let-alist" nil "go-guru" nil "go-rename" nil "restclient-mode" nil "restclient" nil "company-restclient" nil "know-your-http-well" nil "smooth-scrolling" nil "docker-compose-mode" nil "yaml-mode" nil "dockerfile-mode" nil "go-fill-struct" nil "yasnippet" nil "yasnippet-snippets" nil "rich-minority" nil "diminish" nil "zoom-window" nil "vlf" nil)) melpa #s(hash-table size 97 test equal rehash-size 1.5 rehash-threshold 0.8125 data (version 2 "gnu-elpa-mirror" nil "el-get" (el-get :type git :flavor melpa :files ("*.el" ("recipes" "recipes/el-get.rcp") "methods" "el-get-pkg.el") :host github :repo "dimitri/el-get") "emacsmirror-mirror" nil "straight" nil "use-package" (use-package :type git :flavor melpa :files (:defaults (:exclude "bind-key.el" "bind-chord.el" "use-package-chords.el" "use-package-ensure-system-package.el") "use-package-pkg.el") :host github :repo "jwiegley/use-package") "bind-key" (bind-key :type git :flavor melpa :files ("bind-key.el" "bind-key-pkg.el") :host github :repo "jwiegley/use-package") "evil" (evil :type git :flavor melpa :files (:defaults "doc/build/texinfo/evil.texi" (:exclude "evil-test-helpers.el") "evil-pkg.el") :host github :repo "emacs-evil/evil") "goto-chg" (goto-chg :type git :flavor melpa :host github :repo "emacs-evil/goto-chg") "cl-lib" nil "evil-collection" (evil-collection :type git :flavor melpa :files (:defaults "modes" "evil-collection-pkg.el") :host github :repo "emacs-evil/evil-collection") "annalist" (annalist :type git :flavor melpa :host github :repo "noctuid/annalist.el") "solarized-theme" (solarized-theme :type git :flavor melpa :host github :repo "bbatsov/solarized-emacs") "dash" (dash :type git :flavor melpa :files ("dash.el" "dash.texi" "dash-pkg.el") :host github :repo "magnars/dash.el") "better-jumper" (better-jumper :type git :flavor melpa :host github :repo "gilbertw1/better-jumper") "neotree" (neotree :type git :flavor melpa :files (:defaults "icons" "neotree-pkg.el") :host github :repo "jaypei/emacs-neotree") "all-the-icons" (all-the-icons :type git :flavor melpa :files (:defaults "data" "all-the-icons-pkg.el") :host github :repo "domtronn/all-the-icons.el") "ace-window" (ace-window :type git :flavor melpa :host github :repo "abo-abo/ace-window") "avy" (avy :type git :flavor melpa :host github :repo "abo-abo/avy") "airline-themes" (airline-themes :type git :flavor melpa :host github :repo "AnthonyDiGirolamo/airline-themes") "powerline" (powerline :type git :flavor melpa :host github :repo "milkypostman/powerline") "spaceline" (spaceline :type git :flavor melpa :host github :repo "TheBB/spaceline") "s" (s :type git :flavor melpa :files ("s.el" "s-pkg.el") :host github :repo "magnars/s.el") "spaceline-config" nil "rainbow-delimiters" (rainbow-delimiters :type git :flavor melpa :host github :repo "Fanael/rainbow-delimiters") "f" (f :type git :flavor melpa :files ("f.el" "f-pkg.el") :host github :repo "rejeep/f.el") "undo-tree" nil "path-headerline-mode" (path-headerline-mode :type git :flavor melpa :host github :repo "7696122/path-headerline-mode") "powerline-evil" (powerline-evil :type git :flavor melpa :host github :repo "johnson-christopher/powerline-evil") "evil-matchit" (evil-matchit :type git :flavor melpa :host github :repo "redguardtoo/evil-matchit") "evil-leader" (evil-leader :type git :flavor melpa :host github :repo "cofi/evil-leader") "easy-motion" nil "evil-easymotion" (evil-easymotion :type git :flavor melpa :host github :repo "PythonNut/evil-easymotion") "which-key" (which-key :type git :flavor melpa :host github :repo "justbur/emacs-which-key") "remind-bindings" (remind-bindings :type git :flavor melpa :host gitlab :repo "mtekman/remind-bindings.el") "omni-quotes" (omni-quotes :type git :flavor melpa :host github :repo "AdrieanKhisbe/omni-quotes.el") "omni-log" (omni-log :type git :flavor melpa :host github :repo "AdrieanKhisbe/omni-log.el") "ht" (ht :type git :flavor melpa :files ("ht.el" "ht-pkg.el") :host github :repo "Wilfred/ht.el") "popwin" (popwin :type git :flavor melpa :host github :repo "emacsorphanage/popwin") "map" nil "company" (company :type git :flavor melpa :files (:defaults "icons" "company-pkg.el") :host github :repo "company-mode/company-mode") "ido-completing-read+" (ido-completing-read+ :type git :flavor melpa :files ("ido-completing-read+.el" "ido-completing-read+-pkg.el") :host github :repo "DarwinAwardWinner/ido-completing-read-plus") "seq" nil "memoize" (memoize :type git :flavor melpa :host github :repo "skeeto/emacs-memoize") "lsp-mode" (lsp-mode :type git :flavor melpa :files (:defaults "clients/*.el" "lsp-mode-pkg.el") :host github :repo "emacs-lsp/lsp-mode") "spinner" nil "markdown-mode" (markdown-mode :type git :flavor melpa :host github :repo "jrblevin/markdown-mode") "lv" (lv :type git :flavor melpa :files ("lv.el" "lv-pkg.el") :host github :repo "abo-abo/hydra") "lsp-ui" (lsp-ui :type git :flavor melpa :files (:defaults "lsp-ui-doc.html" "resources" "lsp-ui-pkg.el") :host github :repo "emacs-lsp/lsp-ui") "esup" (esup :type git :flavor melpa :host github :repo "jschaf/esup") "treemacs" (treemacs :type git :flavor melpa :files (:defaults "Changelog.org" "icons" "src/elisp/treemacs*.el" "src/scripts/treemacs*.py" (:exclude "src/extra/*") "treemacs-pkg.el") :host github :repo "Alexander-Miller/treemacs") "pfuture" (pfuture :type git :flavor melpa :host github :repo "Alexander-Miller/pfuture") "hydra" (hydra :type git :flavor melpa :files (:defaults (:exclude "lv.el") "hydra-pkg.el") :host github :repo "abo-abo/hydra") "cfrs" (cfrs :type git :flavor melpa :host github :repo "Alexander-Miller/cfrs") "posframe" (posframe :type git :flavor melpa :host github :repo "tumashu/posframe") "company-lsp" nil "lsp-origami" (lsp-origami :type git :flavor melpa :host github :repo "emacs-lsp/lsp-origami") "origami" (origami :type git :flavor melpa :host github :repo "gregsexton/origami.el") "lsp-go" nil "go-mode" (go-mode :type git :flavor melpa :files ("go-mode.el" "go-mode-pkg.el") :host github :repo "dominikh/go-mode.el") "lsp-html" nil "flycheck" (flycheck :type git :flavor melpa :host github :repo "flycheck/flycheck") "pkg-info" (pkg-info :type git :flavor melpa :host github :repo "emacsorphanage/pkg-info") "epl" (epl :type git :flavor melpa :host github :repo "cask/epl") "let-alist" nil "go-guru" (go-guru :type git :flavor melpa :files ("go-guru.el" "go-guru-pkg.el") :host github :repo "dominikh/go-mode.el") "go-rename" (go-rename :type git :flavor melpa :files ("go-rename.el" "go-rename-pkg.el") :host github :repo "dominikh/go-mode.el") "restclient-mode" nil "restclient" (restclient :type git :flavor melpa :files ("restclient.el" "restclient-pkg.el") :host github :repo "pashky/restclient.el") "company-restclient" (company-restclient :type git :flavor melpa :host github :repo "iquiw/company-restclient") "know-your-http-well" (know-your-http-well :type git :flavor melpa :files ("emacs/*.el" "know-your-http-well-pkg.el") :host github :repo "for-GET/know-your-http-well") "smooth-scrolling" (smooth-scrolling :type git :flavor melpa :host github :repo "aspiers/smooth-scrolling") "docker-compose-mode" (docker-compose-mode :type git :flavor melpa :files (:defaults (:exclude "docker-compose-mode-helpers.el") "docker-compose-mode-pkg.el") :host github :repo "meqif/docker-compose-mode") "yaml-mode" (yaml-mode :type git :flavor melpa :host github :repo "yoshiki/yaml-mode") "dockerfile-mode" (dockerfile-mode :type git :flavor melpa :host github :repo "spotify/dockerfile-mode") "go-fill-struct" (go-fill-struct :type git :flavor melpa :host github :repo "s-kostyaev/go-fill-struct") "yasnippet" (yasnippet :type git :flavor melpa :files ("yasnippet.el" "snippets" "yasnippet-pkg.el") :host github :repo "joaotavora/yasnippet") "yasnippet-snippets" (yasnippet-snippets :type git :flavor melpa :files ("*.el" "snippets" ".nosearch" "yasnippet-snippets-pkg.el") :host github :repo "AndreaCrotti/yasnippet-snippets") "rich-minority" (rich-minority :type git :flavor melpa :host github :repo "Malabarba/rich-minority") "diminish" (diminish :type git :flavor melpa :host github :repo "myrjola/diminish.el") "zoom-window" (zoom-window :type git :flavor melpa :host github :repo "emacsorphanage/zoom-window") "vlf" (vlf :type git :flavor melpa :host github :repo "m00natic/vlfi"))) gnu-elpa-mirror #s(hash-table size 65 test equal rehash-size 1.5 rehash-threshold 0.8125 data (version 3 "emacsmirror-mirror" nil "straight" nil "cl-lib" nil "spaceline-config" nil "undo-tree" (undo-tree :type git :host github :repo "emacs-straight/undo-tree" :files ("*" (:exclude ".git"))) "easy-motion" nil "map" (map :type git :host github :repo "emacs-straight/map" :files ("*" (:exclude ".git"))) "seq" nil "spinner" (spinner :type git :host github :repo "emacs-straight/spinner" :files ("*" (:exclude ".git"))) "company-lsp" nil "lsp-go" nil "lsp-html" nil "let-alist" (let-alist :type git :host github :repo "emacs-straight/let-alist" :files ("*" (:exclude ".git"))) "restclient-mode" nil)) el-get #s(hash-table size 65 test equal rehash-size 1.5 rehash-threshold 0.8125 data (version 1 "emacsmirror-mirror" nil "straight" nil "cl-lib" nil "spaceline-config" nil "easy-motion" nil "seq" nil "company-lsp" nil "lsp-go" nil "lsp-html" nil "restclient-mode" nil)) emacsmirror-mirror #s(hash-table size 65 test equal rehash-size 1.5 rehash-threshold 0.8125 data (version 2 "straight" (straight :type git :host github :repo "emacsmirror/straight") "cl-lib" nil "spaceline-config" nil "easy-motion" nil "seq" nil "company-lsp" (company-lsp :type git :host github :repo "emacsattic/company-lsp") "lsp-go" nil "lsp-html" nil "restclient-mode" nil))))

("org-elpa" "melpa" "gnu-elpa-mirror" "el-get" "emacsmirror-mirror" "straight" "emacs" "use-package" "bind-key" "evil" "goto-chg" "cl-lib" "evil-collection" "annalist" "avy" "smooth-scrolling" "evil-leader" "solarized-theme" "dash" "all-the-icons" "ace-window" "path-headerline-mode" "powerline" "airline-themes" "zoom-window" "diminish" "undo-tree" "better-jumper" "neotree" "rainbow-delimiters" "which-key" "remind-bindings" "omni-quotes" "omni-log" "ht" "s" "f" "popwin" "map" "ido-completing-read+" "seq" "memoize" "lsp-mode" "spinner" "markdown-mode" "lv" "flycheck" "pkg-info" "epl" "let-alist" "lsp-ui" "company-lsp" "company" "treemacs" "pfuture" "hydra" "cfrs" "posframe" "lsp-origami" "origami" "go-mode" "go-fill-struct" "esup" "restclient" "docker-compose-mode" "yaml-mode" "dockerfile-mode" "yasnippet" "yasnippet-snippets" "vlf")

t
